<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=0.8, user-scalable=no">
    <title>佩乐点点勒</title>
    <script type="text/javascript" src="vue.js"></script>
    <script type="text/javascript" src="pako.js"></script>
    <script type="text/javascript" src="break_infinity.js"></script>
    <style>
        body {
            text-align: center;
            font-family: MonospaceTypewriter, monospace;
        }

        button {
            text-align: center;
            font-family: MonospaceTypewriter, monospace;
            font-size: 16px;
        }

        .container {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0 auto;
        max-width: 540px;
        width: 95%;
     /* 保持原有其他属性不变 */
        padding: 20px;
        background: #ffffff;
        border-radius: 10px;
        }

/* 移动端适配优化 */
        @media (max-width: 540px) {
            .container {
                width: 95%;
                padding: 10px;
            }
        }

        .header-fixed {
            position: sticky;
            top: 0;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            z-index: 100;
            width: 100%;
        }

        .header-text{
            font-weight: bold;
            line-height:150%;
        }

        .tabs {
            display: grid;
            grid-template-columns: repeat(4, minmax(130px,1fr)); /* 4列 */
            grid-auto-rows: minmax(40px, auto); /* 行高 */
            gap: 5px; /* 间距 */
            margin: 10px 0;
        }

        .tab {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
            font-size: 16px;
        }

        /* 响应式适配 */
        @media (max-width: 540px) {
            .tabs {
                grid-template-columns: repeat(4, minmax(60px,1fr));
            }

            .tab {
                font-size: 16px;
                padding: 5px;
            }
        }

        .active-tab {
            background-color: #f0f0f0;
        }

        .clickable {
            cursor: pointer;
        }

        .click-effects-container {
            position: relative;
            bottom: -50%;
            left: 30%;
            right: 0;
            pointer-events: none;
        }

        .click-effect {
            position: absolute;
            font-size: 16px;
            color: #114514;
            font-weight: bold;
            animation: floatUp 2s ease-out forwards;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-100px);
                opacity: 0;
            }
        }

        /* 响应式调整 */
        @media (max-width: 540px) {
            .big-pei {
                font-size: 80px;
            }

            .click-effect {
                font-size: 18px;
            }
        }

        .golden-pei {
            width: 50px;
            height: 50px;
            background-color: gold;
        }

        .golden-pei-hide {
            width: 50px;
            height: 50px;
            background-color: #cccccc;
        }

        .effect-toast {
            position: fixed;
            right: 20px;
            bottom: 20px;
            background: #fff3e0;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-left: 5px solid #ff9800;
            animation: slideIn 0.3s ease-out;
        }

        .disabled {
            background-color: #ccc;
        }

        .divider {
            line-height:0px;
            color:white;
        }

        .building-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 1fr);
        }

        .building {
            border: 2px solid #ccc;
            border-radius: 8px;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between; /* 添加这行 */
            background: #f8f8f8;
        }

        .bulk-selector {
            margin: 10px 0;
            padding: 5px;
            background: #f0f0f0;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 1fr);
        }

        .upgrade {
            border: 2px solid #ccc;
            border-radius: 4px;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between; /* 添加这行 */
            background: #f8f8f8;
        }

        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 1fr);
        }

        .achievement {
            border: 2px solid #ccc;
            border-radius: 4px;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #f8f8f8;
        }

            .achievement.unlocked {
                border-color: #4CAF50;
                background: #e8f5e9;
            }

        .achievement-icon {
            font-size: 2em;
            margin-right: 15px;
        }

        .achievement-info h4 {
            margin: 0 0 5px 0;
            color: #333;
        }

        .achievement-info p {
            margin: 0;
            color: #666;
        }

        .achievement-info small {
            color: #999;
            font-size: 0.8em;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
            }

            to {
                transform: translateX(0);
            }
        }

        .achievement-toast {
            position: fixed;
            right: 20px;
            bottom: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            animation: slideIn 0.3s ease-out;
            border-left: 5px solid #4CAF50;
        }

        .shop {
            margin-top: 20px;
            border-top: 2px solid #666;
            padding-top: 15px;
        }

        .upgrade-item {
            border: 1px solid #aaa;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            background: #f8f8f8;
        }

            .upgrade-item button {
                margin: 5px 0;
            }

        .offline-toast {
            position: fixed;
            right: 20px;
            bottom: 80px;
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-left: 5px solid #2196F3;
            animation: slideIn 0.3s ease-out;
        }
    </style>
</head>
<body>
    <div id="app" class="container">
        <div class="header-fixed">
            <div class="header-text" style="font-size: 32px;">你有 {{ format(peiCount) }} 佩干</div>
            <div class="header-text" style="font-size: 20px;">{{ format(peiPerSecond) }}/秒</div>
            <div class="header-text" style="font-size: 20px;">{{ format(peiPerClick) }}/点击</div>
        </div>

        <div class="clickable" @click="clickPei" style="width: 200px; height: 200px; background-image: url('pelkie.bmp')">
            <div class="click-effects-container">
                <div v-for="(effect, index) in clickEffects"
                     :key="index"
                     :style="effect.style"
                     class="click-effect">
                    +{{ format(effect.amount) }}
                </div>
            </div>
        </div>

        <div :class="goldenPeiVisible?'golden-pei clickable':'golden-pei-hide'" @click="clickGoldenPei" style="font-size:36px; text-align:center">♅</div>

        <div class="bonus-status">
            <div>牛奶: {{ format(milk) }}</div>
            <div>糖块: {{ format(sugar) }}</div>
        </div>

        <div>金佩勒效果: {{effect}}</div>

        <div class="tabs">
            <div v-for="(tab, index) in tabs" :key="index"
                 class="tab clickable"
                 :class="{ 'active-tab': currentTab === index }"
                 @click="currentTab = index">
                {{ tab }}
            </div>
        </div>

        <!-- 建筑选项卡 -->
        <div v-if="currentTab === 0">
            <div class="bulk-selector">
                购买数量:
                <select v-model="bulkAmount">
                    <option value="1">×1</option>
                    <option value="10">×10</option>
                    <option value="100">×100</option>
                    <option value="1000">×1000</option>
                    <option value="10000">×10000</option>
                    <option value="100000">×100000</option>
                    <option value="1000000">×1000000</option>
                </select>
            </div>
            <div class="building-grid">
                <div class="divider">----------------------------------------------------------------</div>
                <div v-for="(building, index) in buildings" :key="index" class="building">
                    &nbsp;&nbsp;建筑{{ building.id + 1 }}&nbsp;&nbsp;<br />
                    &nbsp;&nbsp;数量:{{ formatInt(building.quantity) }}&nbsp;&nbsp;<br />
                    &nbsp;&nbsp;基础佩干/秒:{{ format(building.baseProd) }}&nbsp;&nbsp;<br />
                    &nbsp;&nbsp;佩干/秒:{{ format(building.production) }}&nbsp;&nbsp;
                    <button @click="buyBuilding(index)"
                            :disabled="peiCount.lt(calcBulkCost(index))">
                        购买 ×{{ bulkAmount }}<br />
                        花费 {{ format(calcBulkCost(index)) }} 佩干
                    </button>
                </div>
            </div>
        </div>

        <!-- 升级选项卡 -->
        <div v-if="currentTab === 1">
            <div style="font-size:24px">升级 ({{ unlockedUpgradesCount }}/{{ upgrades.length }})</div>
            <div class="upgrade-grid">
                <div class="divider">----------------------------------------------------------------</div>
                <div v-for="upgrade in upgrades"
                     :key="upgrade.buildingId*100+upgrade.id"
                     v-if="showUpgrade(upgrade)"
                     class="upgrade">
                    <div>
                        升级{{ upgrade.buildingId }}-{{ upgrade.id }}
                        <span v-show="upgrade.buildingId==1 & upgrade.id<4">点击和建筑 1 生产的佩干×2&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId==1 & upgrade.id==4">每个建筑 2~42 使点击和建筑 1 生产的佩干 +1&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId==1 & upgrade.id>4">升级 1-4 的效果 ×20&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId<100 & upgrade.buildingId>1">建筑 {{upgrade.buildingId}} 的产量 ×2&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId==101">点击获得的佩干 +1% <del>每秒生产的佩干</del></span>
                        <span v-show="upgrade.buildingId==102">释放牛奶力量(叠乘)，佩干产量 ×(1+牛奶*{{format(upgrade.id <= 8 ? upgrade.id <= 4 ? N(0.003).add(0.001 * upgrade.id) : N(0.008) : upgrade.id <= 12 ? N(0.017).sub(0.001 * upgrade.id) : N(0.004))}})&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId==103">建筑 2 的产量 ×2, 建筑 {{upgrade.id+2}} 的产量 +1% 每拥有 {{upgrade.id}} 个建筑 2 </span>
                        <span v-show="upgrade.buildingId==104 & upgrade.id<6">每个累计的现实碎片使佩干产量 +{{Math.max(5,upgrade.id*25-25)}}%</span>
                        <span v-show="upgrade.buildingId==104 & upgrade.id>=6">佩干产量乘数 +{{Math.pow(10,upgrade.id-6)}}%</span>
                        <span v-show="upgrade.buildingId==105">佩干产量乘数 +{{Math.floor((upgrade.id-1)/10)+1}}%</span>
                        <span v-show="upgrade.buildingId==106">佩干产量乘数 +10% (需要每个建筑数量{{upgrade.required}})</span>
                        <span v-show="upgrade.buildingId==107 & upgrade.id==1">金佩勒出现频率翻倍，在屏幕上的持续时间翻倍</span>
                        <span v-show="upgrade.buildingId==107 & upgrade.id==2"><del>金佩勒出现频率翻倍，在屏幕上的持续时间翻倍</del>(被佩勒删除)</span>
                        <span v-show="upgrade.buildingId==107 & upgrade.id==3"><del>金佩勒效果的持续时间翻倍</del>(被佩勒删除)</span>
                        <span v-show="upgrade.buildingId==108">每个建筑 {{upgrade.id+2}} 增加 5% 建筑 {{upgrade.id+1}} 的产量，每个建筑 {{upgrade.id+1}} 增加 0.1% 建筑 {{upgrade.id+2}} 的产量</span>
                        <span v-show="upgrade.buildingId==109">每个建筑 {{upgrade.id+2}} 增加 5% 建筑 {{upgrade.id}} 的产量，每个建筑 {{upgrade.id}} 增加 0.1% 建筑 {{upgrade.id+2}} 的产量</span>
                    </div>
                    <button @click="buyUpgrade(upgrade.id, upgrade.buildingId)"
                            :disabled="!canBuyUpgrade(upgrade.id, upgrade.buildingId)">
                        {{ format(upgrade.cost.mul(goldenPeiEffects.upgradeCostReduction)) }} 佩干
                    </button>
                </div>
            </div>
        </div>

        <!-- 成就选项卡 -->
        <div v-if="currentTab === 2">
            <div style="font-size:24px">成就 ({{ unlockedAchievementsCount }}/{{ achievements.length }})</div>
            <div class="achievement-grid">
                <div class="divider">----------------------------------------------------------------</div>
                <div v-for="achievement in achievements" :key="achievement.buildingId*100+achievement.id" class="achievement" :class="{ 'unlocked': achievement.unlocked }">
                    <div class="achievement-info">
                        {{ achievement.unlocked ? '√' : '×' }} 成就{{ achievement.buildingId }}-{{ achievement.id }}
                        <span v-show="achievement.buildingId<100">拥有 {{formatInt(achievement.required)}} 个建筑 {{achievement.buildingId}}</span>
                        <span v-show="achievement.buildingId==101">累计获得 {{format(achievement.required)}} 个佩干</span>
                        <span v-show="achievement.buildingId==102">每秒生产 {{format(achievement.required)}} 个佩干</span>
                        <span v-show="achievement.buildingId==103">点击获得 {{format(achievement.required)}} 个佩干</span>
                        <span v-show="achievement.buildingId==104">累计获得 {{format(achievement.required)}} 个现实碎片</span>
                        <span v-show="achievement.buildingId==105">累计获得 {{format(achievement.required)}} 个轮回点</span>
                        <span v-show="achievement.buildingId==106">累计获得 {{format(achievement.required)}} 个觉醒点</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 飞升选项卡 -->
        <div v-if="currentTab === 3">
            <div v-if="canAscend">
                <p>飞升获取 {{ format(this.totalShards.sub(this.totalRealityShards).max(0)) }} 现实碎片 (下一个在 {{format(nextShards)}} 佩干)</p>
                <button @click="ascend">飞升!</button>
            </div>
            <div v-else>
                <p>飞升(ascend)需要 1e12 累计佩干 ({{ format(totalLifetimePei) }}/1e12)</p>
            </div>
            <div class="divider">----------------------------------------------------------------</div>
            <div v-if="this.ascensionCount.gte(1)" class="shop">
                <h4>飞升升级 (你有 {{ format(realityShards) }}/{{format(totalRealityShards)}} 现实碎片)</h4>
                <div v-for="upgrade in ascendU" :key="upgrade.id" class="upgrade-item">
                    {{auDescription[upgrade.id-1]}}<br />
                    等级 {{ formatInt(upgrade.level) }}/{{ formatInt(upgrade.maxLevel) }}
                    <button @click="buyAscendU(upgrade.id-1)"
                            :disabled="realityShards.lt(upgrade.cost)">
                        {{ format(upgrade.cost) }} RS
                    </button>
                    <button v-show="ascendU[8].level.gte(1) & upgrade.id==9" @click="switchGolden">
                        金佩勒：{{enableGolden?"启用":"禁用"}}
                    </button>
                    <button v-show="ascendU[16].level.gte(1) & upgrade.id==17" @click="switchClick">
                        点击：{{enableClick?"启用":"禁用"}}
                    </button>
                </div>
            </div>
            <div v-else class="shop">
                <p>飞升一次以解锁</p>
            </div>
        </div>

        <!-- 超越选项卡 -->
        <div v-if="currentTab === 4">

            <div>
                <p>轮回(transcend)获取轮回点(需要1e48累计佩干)</p>
            </div>

        </div>
        <!-- 高产选项卡 -->
        <div v-if="currentTab === 5">

            <div>
                <p>到达1e192累计佩干进行破碎(break),每次破碎需求乘1e16,根据破碎次数获得奖励</p>
                <p>觉醒(hypercend)重置破碎重置的内容但不重置破碎次数，获取觉醒点(需要8次破碎，1e308佩干)</p>
            </div>

        </div>
        <!-- 统计选项卡 -->
        <div v-if="currentTab === 6">
            <h3>统计:</h3>
            <div>当前佩干: {{format(peiCount)}}</div>
            <div>本次飞升中的佩干: {{format(thisAscendPei)}}</div>
            <div>累计佩干: {{format(totalLifetimePei)}}</div>
            <div>佩干每秒: {{format(peiPerSecond)}}</div>
            <div>点击获得的佩干: {{format(totalClickPei)}}</div>
            <div>佩干每次点击: {{format(peiPerClick)}}</div>
            <div>金佩勒点击数: {{goldenPeiClick}}</div>

            <div>飞升次数: {{format(ascensionCount)}}</div>
            <div>当前现实碎片: {{format(realityShards)}}</div>
            <div>累计现实碎片: {{format(totalRealityShards)}}</div>

            <div>游戏时间: {{ Math.floor(totalPlayTime) }}</div>
            <div>糖块计时: {{ Math.floor(playTime) }}/3600</div>
            <div>牛奶乘数: x{{ format(milkBonus) }}</div>
            <div>糖块乘数: x{{ format(sugarBonus) }}</div>
            <div>升级乘数: x{{ format(upgradeBonus) }}</div>
            <div>飞升乘数: x{{ format(ascendBonus) }}</div>
            <!-- 原有统计信息... -->
        </div>
        <!-- 存档选项卡 -->
        <div v-if="currentTab === 7">
            <button @click="saveGame()">导出</button>
            <button @click="loadGame()">导入</button>
            <button @click="hardReset()" style="color:red">硬重置</button>
            <div>
                本游戏参考了《饼干点击》、《亿点放置》、《从细胞到奇点》、《真实割草增量》，<del>你可以点击链接游玩它们</del><br />
                最终目标：到达1e9,000,000,000,000,000佩干并打败佩勒<br />
                Pelle毁灭了你的饼干宇宙，把你的饼干变成了佩勒饼干，你无法逃离被毁灭的饼干宇宙，你在整个游戏中都会受到重大削弱。<br />
                削弱:<br />
                风味饼干升级被删除（天堂升级和建筑数量相关的除外）<br />
                删除研究中心<br />
                删除老奶奶末世<br />
                删除季节<br />
                删除小游戏<br />
                协同升级效果被修改<br />
                无法用糖块升级建筑<br />
                移除了一些飞升升级<br />
                移除了一些成就<br />
                金饼干效果中的"7"变成"6"<br />
                升级和效果中的一些文字被删除<br />
                天堂碎片在1e12后公式变为饼干^1/4<br />
                增强:<br />
                声望等级效果x100<br />
                糖块生长速度×24<br />
                新增22个建筑<br />
                一开始就有6小时80%的离线收益<br />
                新声望层级:轮回,在1e48累计饼干后解锁<br />
                新声望层级:破碎/觉醒,在1e192/1e308累计饼干后解锁<br />
            </div>
        </div>
    </div>

    <script>
        var formatsave = {
            encoder: new TextEncoder(),
            decoder: new TextDecoder(),
            startString: 'PelkieClickerSaveFormat',
            endString: 'EndOfSaveFile',
            steps: [{
                encode: JSON.stringify,
                decode: JSON.parse
            },
            {
                encode: x => formatsave.encoder.encode(x),
                decode: x => formatsave.decoder.decode(x)
            },
            {
                encode: x => pako.deflate(x),
                decode: x => pako.inflate(x)
            },
            {
                encode: x => Array.from(x).map(i => String.fromCharCode(i)).join(""),
                decode: x => Uint8Array.from(Array.from(x).map(i => i.charCodeAt(0)))
            },
            {
                encode: x => btoa(x),
                decode: x => atob(x)
            },
            {
                encode: x => x.replace(/=+$/g, "").replace(/0/g, "0a").replace(/\+/g, "0b").replace(/\//g, "0c"),
                decode: x => x.replace(/0b/g, "+").replace(/0c/g, "/").replace(/0a/g, "0")
            },
            {
                encode: x => formatsave.startString + x + formatsave.endString,
                decode: x => x.slice(formatsave.startString.length, -formatsave.endString.length),
            }
            ],
            encode(s) {
                return this.steps.reduce((x, f) => f.encode(x), s);
            },
            decode(s) {
                return this.steps.reduceRight((x, f) => f.decode(x), s);
            },
        }

        function transformToDecimal(object) {
            for (i in object) {
                if (typeof (object[i]) == 'string' && !isNaN(N(object[i]).m)) object[i] = N(object[i]);
                if (typeof (object[i]) == 'object') transformToDecimal(object[i]);
            }
        }

        function data_print() {
            localStorage.PelkieClickerSave = formatsave.encode(JSON.stringify(data));
        }

        function data_input() {
            if (!localStorage.PelkieClickerSave) return;
            if (localStorage.PelkieClickerSave[0] == 'e') data = JSON.parse(atob(localStorage.PelkieClickerSave));
            else data = JSON.parse(formatsave.decode(localStorage.PelkieClickerSave));
            transformToDecimal(data);
        }

        async function jtb(text) {
            try {
                await navigator.clipboard.writeText(text);
                console.log('Text copied to clipboard');
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }

        function export_save() {
            jtb(formatsave.encode(JSON.stringify(data)));
        }

        function import_save() {
            let userInput = prompt("导入：", "输入存档");
            if (userInput != null && userInput !== "") {
                if (userInput[0] == 'e') data = JSON.parse(atob(userInput));
                else data = JSON.parse(formatsave.decode(userInput));
                transformToDecimal(data);
                data_print();
                location.reload();
            } else {
            }
        }

        function N(num) {
            return new Decimal(num);
        }
        const UPGRADES = (() => {
            const upgrades = [];
            upgrades.push({
                id: 0,
                buildingId: 1,
                required: N(0),
                cost: N(40),
            })
            //升级1~1050:建筑乘数升级
            for (let i = 1; i <= 1050; i++) {
                let index = (i-1) % 25 + 1;
                let bIndex = Math.floor((i-1) / 25);
                let costMult = [10,50,500,50000,5e6,5e9,5e12,5e15,5e18,5e21,5e24,5e27,5e30,5e33,5e36,5e39,5e42,5e48,5e54,5e60,5e96,5e150,5e240,'5e390','5e600'];
                let requirement = [1,5,25,50,100,150,200,250,300,350,400,450,500,550,600,650,700,800,900,1000,1600,2500,4000,6500,10000];
                upgrades.push({
                    id: index,
                    buildingId: bIndex+1,
                    required: N(requirement[index-1]),
                    cost: N(costMult[index-1]).mul(Math.pow(10, bIndex * (bIndex - 1) / 40 + bIndex + 1)),
                })
            }
            //升级1051~1070:点击乘数
            for (let i = 1; i <= 20; i++) {
                upgrades.push({
                    id: i,
                    buildingId: 101,
                    required: N(100).pow(i),
                    cost: N(100).pow(i).mul(5),
                })
            }
            //升级1071~1110:牛奶乘数
            for (let i = 1; i <= 40; i++) {
                upgrades.push({
                    id: i,
                    buildingId: 102,
                    required: i==1?N(10):N(25).mul(i-1),
                    cost: N(1000).pow(i).mul(9000),
                })
            }
            //升级1111~1150:建筑2协同
            for (let i = 1; i <= 40; i++) {
                upgrades.push({
                    id: i,
                    buildingId: 103,
                    required: N(20),
                    cost: N(Math.pow(10, i * (i - 1) / 40 + i + 1)).mul(200),
                })
            }
            //升级1151~1160:飞升效果
            for (let i = 1; i <= 10; i++) {
                let costs = [11, 1111, 111111, 11111111, 1111111111, 100, 1e12, 1e72, "1e432", "1e2592"];
                upgrades.push({
                    id: i,
                    buildingId: 104,
                    required: i,
                    cost: N(costs[i-1]),
                })
            }
            //升级1161~1250:飞升风味佩干
            for (let i = 1; i <= 90; i++) {
                let costs = [];
                upgrades.push({
                    id: i,
                    buildingId: 105,
                    required: N(Math.floor((i-1)/10)+1),
                    cost: N(1e10).mul(N(10).pow(i/5)),
                })
            }
            //升级1251~1290:建筑产量风味佩干
            for (let i = 1; i <= 40; i++) {
                upgrades.push({
                    id: i,
                    buildingId: 106,
                    required: i<=13?i*50+50:i<=22?i*1000-12000:i<=31?i*10000-210000:i*100000-3000000,
                    cost: i<=13?N(1000).pow(i).mul(1e26):i<=22?N(1e60).pow(i-12):i<=31?N("1e600").pow(i-21):N("1e6000").pow(i-30),
                })
            }
            //升级1291~1299:金佩勒升级
            upgrades.push({
                id: 1,
                buildingId: 107,
                required: 7,
                cost: N(777777777),
            })//金佩乐出现频率加倍且持续时间加倍. other 2 upgrades are deleted by pelle.
            upgrades.push({
                id: 2,
                buildingId: 107,
                required: 27,
                cost: N(77777777777),
            })
            upgrades.push({
                id: 3,
                buildingId: 107,
                required: 77,
                cost: N(77777777777777),
            })
            for (let i = 1; i <= 7; i++) {
                upgrades.push({
                    id: i+3,
                    buildingId: 107,
                    required: 9e15,
                    cost: N("e9e15"),
                })
            }
            //升级1300~1339:飞升团结I升级,需要15个建筑
            for (let i = 1; i <= 40; i++) {
                upgrades.push({
                    id: i,
                    buildingId: 108,
                    required: N(15),
                    cost: N(Math.pow(10, (i + 2) * (i + 1) / 40 + i + 3)).mul(100),
                })
            }
            //升级1340~1379:飞升团结II升级,需要75个建筑
            for (let i = 1; i <= 40; i++) {
                upgrades.push({
                    id: i,
                    buildingId: 109,
                    required: N(75),
                    cost: N(Math.pow(10, (i + 2) * (i + 1) / 40 + i + 3)).mul(5e5),
                })
            }
            //其他升级……
            return upgrades;
        })();
        const ACHIEVEMENTS = (() => {
            const achievements = [];
            //成就 :累计获得的佩干数量
            for (let i = 1; i <= 25; i++) {
                let targetT = i <= 16 ? N(100).pow(i) : N(10).pow(N(10).pow(i - 15));
                achievements.push({
                    id: i,
                    buildingId: 101,
                    required: targetT,
                })
            }
            //成就 :每秒获得的佩干数量
            for (let i = 1; i <= 25; i++) {
                let targetS = i <= 16 ? N(10).pow(i) : N(10).pow(N(10).pow(i - 15));
                achievements.push({
                    id: i,
                    buildingId: 102,
                    required: targetS,
                })
            }
            //成就 :点击获得的佩干数量
            for (let i = 1; i <= 25; i++) {
                let targetC = i <= 16 ? N(100).pow(i) : N(10).pow(N(10).pow(i - 15));
                achievements.push({
                    id: i,
                    buildingId: 103,
                    required: targetC,
                })
            }
            //成就 :拥有的建筑数量
            for (let i = 1; i <= 1050; i++) {
                let target = [1,50,100,150,200,250,300,350,400,450,500,600,700,800,900,1000,2000,3000,4000,5000,6000,7000,8000,9000,10000];
                achievements.push({
                    id: (i  -1) % 25 + 1,
                    buildingId: Math.floor((i-1)/25) + 1,
                    required: N(target[(i - 1) % 25]),
                })
            }
            //成就 :飞升层级成就
            for (let i = 1; i <= 25; i++) {
                let target = i <= 10 ? N(10).pow(i-1) : N(1e10).pow(i-10);
                achievements.push({
                    id: i,
                    buildingId: 104,
                    required: target,
                })
            }
            //成就 :超越层级成就
            for (let i = 1; i <= 25; i++) {
                let target = i <= 10 ? N(10).pow(i-1) : N(1e10).pow(i-10);
                achievements.push({
                    id: i,
                    buildingId: 105,
                    required: target,
                })
            }
            //成就 :觉醒层级成就
            for (let i = 1; i <= 25; i++) {
                let target = i <= 10 ? N(10).pow(i-1) : N(1e10).pow(i-10);
                achievements.push({
                    id: i,
                    buildingId: 106,
                    required: target,
                })
            }
            //成就 :其他……
            return achievements;
        })();
        const ASCENDU = (() => {
            const ascendU = [];
            ascendU.push({ id: 1, cost: N(1), maxLevel: N(1) });//解锁飞升系统
            ascendU.push({ id: 2, cost: N(3), maxLevel: N(3) });//佩干产量乘数+10% 3,3e3,3e6
            ascendU.push({ id: 3, cost: N(5), maxLevel: N(5) });//解锁风味佩干 5+n*10
            ascendU.push({ id: 4, cost: N(7), maxLevel: N(7) });//离线时长 7^(n+1)
            ascendU.push({ id: 5, cost: N(50), maxLevel: N(2) });//初始拥有10建筑1或2 50*10^2n
            ascendU.push({ id: 6, cost: N(77), maxLevel: N(10) });//金佩干出现频率提升10% 77*10^2n
            ascendU.push({ id: 7, cost: N(100), maxLevel: N(5) });//背包 n*10^2n
            ascendU.push({ id: 8, cost: N(777), maxLevel: N(10) });//金佩干技能时间提升10% 777*10^2n
            ascendU.push({ id: 9, cost: N(999), maxLevel: N(6) });//禁用金佩干，pps+40+10等级% 999*10^3n
            ascendU.push({ id: 10, cost: N(9000), maxLevel: N(2) });//牛奶效果加成
            ascendU.push({ id: 11, cost: N(99999), maxLevel: N(10) });//建筑、升级价格降低1% 99999*10^5n
            ascendU.push({ id: 12, cost: N(222222), maxLevel: N(2) });//解锁协同升级，当拥有15和75个建筑时出现
            ascendU.push({ id: 13, cost: N(399999), maxLevel: N(1) });//升级价格除以5
            ascendU.push({ id: 14, cost: N(1.5e7), maxLevel: N(1) });//1-6到1-20的乘数变为1000
            ascendU.push({ id: 15, cost: N(1e8), maxLevel: N(10) });//糖块生长10%更快
            ascendU.push({ id: 16, cost: N(2e8), maxLevel: N(10) });//释放糖块力量
            ascendU.push({ id: 17, cost: N(1e9), maxLevel: N(6) });//禁用点击，pps+40+10等级% 10^(2n+9)
            ascendU.push({ id: 18, cost: N(2e9), maxLevel: N(1) });//建筑2升级变为x4
            ascendU.push({ id: 19, cost: N(9e9), maxLevel: N(5) });//牛奶价格降低10%
            ascendU.push({ id: 20, cost: N(3.2e10), maxLevel: N(40) });//解锁不受束缚的升级
            return ascendU;
        })();
        const player={

        }
        new Vue({
            el: '#app',
            data: {
                currentTab: 0,
                tabs: ['建筑', '升级', '成就', '飞升', '轮回', '觉醒', '统计', '存档'],
                peiCount: N(0),
                thisAscendPei: N(0),
                totalLifetimePei: N(0),
                totalClickPei: N(0),
                peiPerSecond: N(0),
                peiPerClick: N(1),
                bulkAmount: 1,
                goldenPeiClick: 0,
                goldenPeiTimer: 0,
                goldenPeiVisible: false,
                goldenPeiEffects: {
                    clickMultiplier: N(1),
                    buildingMultiplier: N(1),
                    buildingCostReduction: N(1),
                    upgradeCostReduction: N(1),
                    randomBuildingBoost: null
                },
                effect: `无`,
                activeEffects: [],
                effectTimers: {},
                clickEffects: [],
                enableGolden: true,
                enableClick: true,

                buildings: Array.from({ length: 42 }, (_, i) => ({
                    id: i,
                    quantity: N(0),
                    baseCost: N(10).pow(i * (i - 1) / 40 + i + 1),
                    cost: N(10).pow(i * (i - 1) / 40 + i + 1),
                    baseProd: N(8).pow(i - 1),
                    production: N(8).pow(i - 1),
                })),
                upgrades: UPGRADES.map(u => ({
                    ...u,
                    unlocked: false,
                })),
                achievements: ACHIEVEMENTS.map(a => ({
                    ...a,
                    unlocked: false,
                })),

                ascensionCount: N(0),
                realityShards: N(0),
                totalRealityShards: N(0),
                ascendU: ASCENDU.map(r => ({
                    ...r,
                    unlocked: false,
                    level: N(0),
                })),
                auDescription: [
                    "神啊！（解锁飞升系统和升级）",
                    "一个残余物（佩干产量乘数+10%）",
                    "佩勒的5个裂隙（每级解锁10种风味佩干）",
                    "6小时后更新（离线生产增加6小时）",
                    "飞升后保留10个前[该升级等级]种建筑",
                    "每级使金佩勒出现频率提升10%",
                    "飞升后保留前[该升级等级]个释放牛奶力量的升级",
                    "每级使金佩勒技能时间提升10%",
                    "可以选择禁用黄金佩干，获得等级*10+40%佩干产量提升",
                    "释放牛奶力量，佩干产量×(1+0.004×牛奶)",
                    "每级使建筑和升级的价格降低1%",
                    "每级解锁40个协同升级，需要15或75个对应建筑",
                    "升级的价格除以5",
                    "升级1-6到1-20的乘数变为1000",
                    "每级使糖块生长的速度增加10%",
                    "释放糖块力量（叠乘），佩干产量×(1+0.001×糖块)",
                    "可以选择禁用点击，获得等级*10+40%佩干产量提升",
                    "建筑2产量提升的升级效果变为x4",
                    "牛奶价格降低10%",
                    "解锁不受束缚的升级，它们提高建筑3~42的升级效果",
                ],

                transcensionCount: N(0),
                transPoints: N(0),
                totalTransPoints: N(0),

                tuDescription:[
                    "每级提升20%每秒佩干获取（叠乘）",
                    "每级提升20%点击佩干获取（叠乘）",
                    "每级使建筑和升级的价格减少1%（每级乘以0.99）",
                    "每级使禁用金佩勒和点击的产量加成+10%",
                    "每级使建筑1升级5~20的乘数+10%",
                    "每级使糖块之运增加100(糖块获得数量+10%)",
                    "每级使每个成就提供的牛奶+10%",
                    "每级使轮回乘数提高10%",
                    "每级使飞升乘数提高10%",
                    "每级使金佩勒效果乘数+10%",
                    "每级使协同升级系列1的效果+10%",
                    "每级使协同升级系列2的效果+10%",
                    //普通轮回升级：1、每次轮回后保留100建筑；2、每次轮回后保留升级105；3、禁用金佩勒和点击的乘数常时生效；4、增加金佩勒出现频率
                ],

                breakCount: N(0),
                hypercensionCount: N(0),
                hyperPoints: N(0),
                totalHyperPoints: N(0),

                bmDescription:[
                    "1破碎：永久解锁自动化选项卡，且每次破碎使佩干产量×4",
                    "2破碎：每次破碎使飞升乘数翻倍",
                    "3破碎：每次破碎使轮回乘数翻倍",
                    "4破碎：每次破碎使每次糖块获取数量+1（从4破碎开始）",
                    "5破碎：飞升次数对佩干产量的加数变为100%",
                    "6破碎：轮回次数对佩干产量的加数变为100%",
                    "7破碎：每个成就提供的牛奶翻倍(爆炸)",
                    "8破碎：解锁觉醒重置，破碎不再重置建筑和升级，解锁觉醒神器",
                    "9破碎：解锁一些新的升级",
                    "10破碎：每次破碎使觉醒点获取量+25%",
                    "12破碎：从12破碎开始，每次破碎使觉醒充能翻倍",
                    "14破碎：从14破碎开始，每次破碎使觉醒充能效果+10%",
                    "16破碎：每次破碎使化石饼干产量+50%",
                    "18破碎：每次破碎使副本1等级升级速度+25%",
                    "20破碎：从20破碎开始，觉醒充能效果每次破碎乘以1.1",
                    "30破碎：……",
                ],

                hmDescription:[
                    "根据你的觉醒点数提升佩干获取和觉醒充能速度",//5HP(hypercension point,觉醒点)
                    "基于最高觉醒点数增加神器1效果",//10
                    "基于当前觉醒点数增加神器2效果",//15
                    "基于当前轮回点数增加神器1/2/3效果",//30
                    "基于判定中的觉醒点数增加神器4效果",//100
                    "神器1效果再次乘以神器4的效果",//300
                    "基于最高觉醒点增加觉醒点乘数",//1500
                    "基于糖块数量，增加神器1/2/3/4/5的效果",
                    "基于累计轮回点数增加觉醒乘数",
                    "神器4和神器8的效果再生效一次",
                    "基于神器8的效果提升神器7的效果",
                    "基于累计轮回点提升神器1/2/3/4/5/8/9/11的效果",
                    "使神器12的效果对它自己生效",
                    "使神器12的效果乘以它的的1/3次方",
                    "使神器14的效果再生效一次",
                    "根据盐块(月光石)的数量，提升神器1/2/3/4/5/8/9/11/12的效果",
                    "基于觉醒点数提升神器16的效果",
                    "基于甜度数量提升神器17的效果",
                    "神器16/17/18的效果^1.02",
                    "基于平衡数量提升神器16/17/18的效果",
                    "基于挑战完成数量提升神器16/17/18的效果",
                    "基于挑战点数提升神器16/17/18的效果",
                    "提升之前所有神器的效果(就是神器1乘数^1.5)",
                ],

                unlockedMisval: false,
                fossilkie: N(0),
                
                unlockedBeyond: false,
                stardukie: N(0),

                unlockedExplor: false,


                milk: N(0),
                sugar: N(0),
                playTime: N(0),
                totalPlayTime: N(0),
                lastUpdateTime: Date.now(),
                // 其他数据...
            },
            methods: {
                clickPei() {
                    if(!this.enableClick) return;
                    this.peiCount = this.peiCount.add(this.peiPerClick);
                    this.totalClickPei = this.totalClickPei.add(this.peiPerClick);
                    this.totalLifetimePei = this.totalLifetimePei.add(this.peiPerClick);
                    this.addClickEffect(this.peiPerClick);
                    // 检查成就
                    this.checkAchievements(103);
                },
                addClickEffect(amount) {
                    const effect = {
                        amount: amount,
                        style: {
                            animationDuration: `2s`
                        }
                    };
                    this.clickEffects.push(effect);

                    // 1秒后移除效果
                    setTimeout(() => {
                        this.clickEffects = this.clickEffects.filter(e => e !== effect);
                    }, 2000);
                },
                switchClick(){
                    this.enableClick = !this.enableClick;
                },
                switchGolden(){
                    this.enableGolden = !this.enableGolden;
                },
                clickGoldenPei() {
                    if (!this.goldenPeiVisible || !this.enableGolden) return;
                    this.goldenPeiClick++;
                    const durationMult=this.ascendU[5].level.mul(0.1).add(1).toNumber();
                    const effects = [
                        {
                            name: '获得15<del>分钟</del>产量的佩干',
                            chance: 9,
                            apply: () => this.gainProduction(15)
                        },
                        {
                            name: '获得的佩干×6，持续66秒',
                            chance: 6,
                            apply: () => this.applyBuildingMultiplier(6, 66*durationMult)
                        },
                        {
                            name: '点击获得的佩干×666，持续13秒',
                            chance: 6,
                            apply: () => this.applyClickMultiplier(666, 13*durationMult)
                        },
                        {
                            name: '随机建筑产量提升<del>该建筑数量×</del>10%，持续30秒',
                            chance: 4,
                            apply: () => this.boostRandomBuilding(1.1, 30*durationMult)
                        },
                        {
                            name: '获得的佩干×15，持续30秒',
                            chance: 3,
                            apply: () => this.applyBuildingMultiplier(15, 30*durationMult)
                        },
                        {
                            name: '点击获得的佩干×1111，持续8秒',
                            chance: 3,
                            apply: () => this.applyClickMultiplier(1111, 8*durationMult)
                        },
                        {
                            name: '建筑价格-50%，持续5秒',
                            chance: 2,
                            apply: () => this.applyBuildingCostReduction(0.5, 5*durationMult)
                        },
                        {
                            name: '升级价格-50%，持续5秒',
                            chance: 2,
                            apply: () => this.applyUpgradeCostReduction(0.5, 5*durationMult)
                        },
                        {
                            name: '获得1个糖块',
                            chance: 1,
                            apply: () => this.gainCandy()
                        },
                    ];
                    const allEffects = [...effects];
                    const selectedEffect = this.selectRandomEffect(allEffects);
                    selectedEffect.apply();
                    this.goldenPeiVisible = false;
                    this.showEffectNotification(selectedEffect.name);
                },
                applyClickMultiplier(multiplier, duration) {
                    this.goldenPeiEffects.clickMultiplier = N(multiplier);
                    this.startEffectTimer('clickMultiplier', () => {
                        this.goldenPeiEffects.clickMultiplier = N(1);
                    }, duration * 1000);
                },
                applyBuildingMultiplier(multiplier, duration) {
                    this.goldenPeiEffects.buildingMultiplier = N(multiplier);
                    this.startEffectTimer('buildingMultiplier', () => {
                        this.goldenPeiEffects.buildingMultiplier = N(1);
                    }, duration * 1000);
                },
                applyBuildingCostReduction(factor, duration) {
                    this.goldenPeiEffects.buildingCostReduction = N(factor);
                    this.startEffectTimer('buildingCostReduction', () => {
                        this.goldenPeiEffects.buildingCostReduction = N(1);
                    }, duration * 1000);
                },
                applyUpgradeCostReduction(factor, duration) {
                    this.goldenPeiEffects.upgradeCostReduction = N(factor);
                    this.startEffectTimer('upgradeCostReduction', () => {
                        this.goldenPeiEffects.upgradeCostReduction = N(1);
                    }, duration * 1000);
                },
                boostRandomBuilding(multiplier, duration) {
                    const buildingsWithQuantity = this.buildings.filter(b => b.quantity.gt(0));
                    if (buildingsWithQuantity.length === 0) return;
                    const randomBuilding = buildingsWithQuantity[
                        Math.floor(Math.random() * buildingsWithQuantity.length)
                    ];

                    this.goldenPeiEffects.randomBuildingBoost = randomBuilding.id;

                    this.startEffectTimer('randomBuildingBoost', () => {
                        this.goldenPeiEffects.randomBuildingBoost = null;
                    }, duration * 1000);
                },
                gainProduction(seconds) {
                    const production = this.peiPerSecond.mul(seconds);
                    this.peiCount = this.peiCount.add(production);
                },
                gainClicks(count) {
                    const total = this.peiPerClick.mul(count);
                    this.peiCount = this.peiCount.add(total);
                },
                gainCandy() {
                    this.sugar = this.sugar.add(1);
                },
                selectRandomEffect(effects) {
                    const totalWeight = effects.reduce((sum, e) => sum + e.chance, 0);
                    let random = Math.random() * totalWeight;
                    for (const effect of effects) {
                        if (random < effect.chance) return effect;
                        random -= effect.chance;
                    }
                    return effects[0];
                },
                startEffectTimer(name, callback, duration) {
                    if (this.effectTimers[name]) {
                        clearTimeout(this.effectTimers[name]);
                    }
                    this.effectTimers[name] = setTimeout(() => {
                        callback();
                        delete this.effectTimers[name];
                    }, duration);
                },
                showEffectNotification(effectName) {
                    this.effect = effectName;
                    const toast = document.createElement('div');
                    toast.className = 'effect-toast';
                    toast.innerHTML = `
                        <span>获得金佩勒效果:${effectName}</span>
            `       ;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 5000);
                },
                buyBuilding(index) {
                    const building = this.buildings[index];
                    const amount = parseInt(this.bulkAmount);
                    const totalCost = this.calcBulkCost(index);
                    if (this.peiCount.lt(totalCost)) return;
                    // 执行购买
                    this.peiCount = this.peiCount.sub(totalCost);
                    building.quantity = building.quantity.add(amount);
                    // 更新下次购买价格（使用公式代替循环）
                    building.cost = building.baseCost.mul(new Decimal(1.148698354997035).pow(building.quantity));
                    // 检查成就
                    this.checkAchievements(index + 1);
                    this.checkAchievements(102);
                },
                calcBulkCost(index) {
                    const building = this.buildings[index];
                    const r = new Decimal(1.148698354997035); // 价格增长系数
                    const n = N(parseInt(this.bulkAmount));
                    const a1 = building.cost;
                    if (n == 1) return a1.mul(this.goldenPeiEffects.buildingCostReduction);
                    // 使用等比数列求和公式：S = a1*(r^n - 1)/(r - 1)
                    return r.pow(n).sub(1).mul(a1).div(r.sub(1)).mul(this.goldenPeiEffects.buildingCostReduction);
                },
                canBulkBuy(index) {
                    return this.peiCount.gte(this.calcBulkCost(index));
                },
                buyUpgrade(i, b) {
                    const upgrade = this.upgrades.filter(u => u.id == i && u.buildingId == b)
                    const c = upgrade[0].cost.mul(this.goldenPeiEffects.upgradeCostReduction);
                    if (this.canBuyUpgrade(i , b)) {
                        this.peiCount = this.peiCount.sub(c);
                        this.upgrades.filter(u => u.id == i && u.buildingId == b).map(u => u.unlocked = true);
                    }
                    //检查成就
                    this.checkAchievements(102);
                },
                // 判断是否可以购买升级
                canBuyUpgrade(i , b) {
                    const upgrade = this.upgrades.filter(u => u.id == i && u.buildingId == b);
                    const c = upgrade[0].cost.mul(this.goldenPeiEffects.upgradeCostReduction);
                    return this.peiCount.gte(c) && !upgrade[0].unlocked
                },
                // 判断升级是否显示
                showUpgrade(u) {
                    if (u.unlocked) return false;
                    else return ((u.buildingId < 100 && this.buildings[u.buildingId - 1].quantity.gte(u.required)) 
                    || (u.buildingId == 101 && this.totalClickPei.gte(u.required)) 
                    || (u.buildingId == 102 && N(this.unlockedAchievementsCount).gte(u.required)) 
                    || (u.buildingId == 103 && this.buildings[u.id + 1].quantity.gte(u.required)) 
                    || (u.buildingId == 104 && this.ascendU[0].level.gte(1)) 
                    || (u.buildingId == 105 && this.ascendU[2].level.gte(u.required) && this.thisAscendPei.gte(u.cost)) 
                    || (u.buildingId == 106 && this.buildings[41].quantity.gte(u.required) && u.id<=13)
                    || (u.buildingId == 107 && this.goldenPeiClick >= u.required)
                    || (u.buildingId == 108 && this.ascendU[11].level.gte(1) && this.buildings[u.id + 1].quantity.gte(15))
                    || (u.buildingId == 109 && this.ascendU[11].level.gte(2) && this.buildings[u.id + 1].quantity.gte(75))
                    );
                },
                checkAchievements(buildingIndex) {
                    const relatedAchievements = this.achievements.filter(
                        a => a.buildingId === buildingIndex
                    );
                    if (buildingIndex < 100) {
                        const building = this.buildings[buildingIndex-1];
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && building.quantity.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                    if (buildingIndex == 101) {
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && this.totalLifetimePei.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                    if (buildingIndex == 102) {
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && this.peiPerSecond.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                    if (buildingIndex == 103) {
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && this.totalClickPei.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                    if (buildingIndex == 104) {
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && this.totalRealityShards.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                },
                showAchievementToast(achievement) {
                    this.milk = N(this.unlockedAchievementsCount);
                    const toast = document.createElement('div');
                    toast.className = 'achievement-toast';
                    toast.innerHTML = `
                <span>成就 </span>
                <strong>${achievement.buildingId}-${achievement.id}</strong>
                <span> 已解锁</span>`
                    ;
                    document.body.appendChild(toast);

                    setTimeout(() => {
                        toast.remove();
                    }, 5000);
                },
                ascend() {
                    if (!this.canAscend) return;

                    // 计算获得的碎片
                    const gained = this.totalShards.sub(this.totalRealityShards).max(0);
                    this.realityShards = this.realityShards.add(gained);
                    this.totalRealityShards = this.totalShards;
                    this.ascensionCount = this.ascensionCount.add(1);
                    this.checkAchievements(104);
                    // 重置游戏状态
                    this.peiCount = N(0);
                    this.thisAscendPei = N(0);
                    this.buildings.forEach(b => {
                        b.quantity = N(0);
                        b.cost = b.baseCost;
                        b.production = b.baseProd;
                    });
                    this.upgrades.forEach(u => {
                        u.unlocked = false;
                    });
                    if(this.ascendU[4].level.gte(1)) this.buildings[0].quantity=N(10);
                    if(this.ascendU[4].level.gte(2)) this.buildings[1].quantity=N(10);
                    for(let i=1; i<=this.ascendU[6].level.toNumber(); i++) this.upgrades[1070+i].unlocked=true;
                },
                buyAscendU(index) {
                    const upgrade = this.ascendU[index];
                    if (upgrade.level.gte(upgrade.maxLevel)) return;

                    if (this.realityShards.gte(upgrade.cost)) {
                        this.realityShards = this.realityShards.sub(upgrade.cost);
                        this.ascendU[index].level = this.ascendU[index].level.add(1);
                    }
                    //const a0=[1,3,5,7,50,77,100,777,999,9000,99999,222222,399999,1.5e7,1e8,2e8,1e9,2e9,9e9,3e10]
                    //const p=[0,667,0,10,0,0,0,100,0,0,0,0,2e6,0,0,0,0,0,0,0,0]
                    //const q=[1,1,1,7,100,10,100,10,100,1e6,2,1,1,1,4,4,100,1,1000,3]
                    //cost=a0+l.mul(p).mul(pow(q,l))
                    if (index == 1) this.ascendU[1].cost = N(3).add(this.ascendU[1].level.mul(667));
                    if (index == 2) this.ascendU[2].cost = N(5).add(this.ascendU[2].level.mul(10));
                    if (index == 3) this.ascendU[3].cost = N(7).pow(this.ascendU[3].level.add(1));
                    if (index == 4) this.ascendU[4].cost = N(50).mul(N(100).pow(this.ascendU[4].level));
                    if (index == 5) this.ascendU[5].cost = N(77).mul(N(10).pow(this.ascendU[5].level));
                    if (index == 6) this.ascendU[6].cost = this.ascendU[6].level.add(1).mul(N(100).pow(this.ascendU[6].level.add(1)));
                    if (index == 7) this.ascendU[7].cost = N(777).mul(N(10).pow(this.ascendU[7].level));
                    if (index == 8) this.ascendU[8].cost = N(999).mul(N(100).pow(this.ascendU[8].level));
                    if (index == 9) this.ascendU[9].cost = N(9000).mul(N(1e12).pow(this.ascendU[9].level));
                    if (index == 10) this.ascendU[10].cost = N(99999).mul(N(2).pow(this.ascendU[10].level));
                    if (index == 11) this.ascendU[11].cost = N(222222).add(this.ascendU[11].level.mul(2e6));
                    if (index == 12) this.ascendU[12].cost = N(399999);
                    if (index == 13) this.ascendU[13].cost = N(1.5e7);
                    if (index == 14) this.ascendU[14].cost = N(1e8).mul(N(4).pow(this.ascendU[14].level));
                    if (index == 15) this.ascendU[15].cost = N(2e8).mul(N(4).pow(this.ascendU[15].level));
                    if (index == 16) this.ascendU[16].cost = N(1e9).mul(N(100).pow(this.ascendU[16].level));
                    if (index == 17) this.ascendU[17].cost = N(2e9);
                    if (index == 18) this.ascendU[18].cost = N(9e9).mul(N(1000).pow(this.ascendU[18].level));
                    if (index == 19) this.ascendU[19].cost = N(3e10).mul(N(3).pow(this.ascendU[19].level));
                },
                format(decimal) {
                    let e = decimal.exponent.toFixed(0);
                    let m = decimal.mantissa.toFixed(3);
                    let ee = Math.floor(Math.log10(decimal.exponent)).toFixed(0);
                    let mm = (decimal.exponent / Math.pow(10, ee)).toFixed(3);
                    if(m == "10.000") m = "9.999";
                    if (mm == "10.000") mm = "9.999";
                    if (decimal.lt(10)) return decimal.toFixed(3);
                    if (decimal.lt(100)) return decimal.toFixed(2);
                    if (decimal.lt(1000)) return decimal.toFixed(1);
                    else if (decimal.lt(1e12)) return this.comma(decimal);
                    else if (decimal.lt("1e1000000000000")) return m + "e" + this.comma(e);
                    else return m + "e" + mm + "e" + ee;
                },
                formatInt(decimal) {
                    let e = decimal.exponent.toFixed(0);
                    let m = decimal.mantissa.toFixed(3);
                    let ee = Math.floor(Math.log10(decimal.exponent)).toFixed(0);
                    let mm = (decimal.exponent / Math.pow(10, ee)).toFixed(3);
                    if (m == "10.000") m = "9.999";
                    if (mm == "10.000") mm = "9.999";
                    else if (decimal.lt(1e12)) return this.comma(decimal);
                    else if (decimal.lt("1e1000000000000")) return m + "e" + this.comma(e);
                    else return m + "e" + mm + "e" + ee;
                },
                comma(num) {
                    if (num === null || num === undefined) return "END"
                    let init = num.toString()
                    let portions = init.split(".")
                    portions[0] = portions[0].replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,")
                    return portions[0]
                },
                saveGame() {
                    // 1. 获取原始数据
                    const saveData = {
                        peiCount: this.peiCount,
                        thisAscendPei: this.thisAscendPei,
                        totalLifetimePei: this.totalLifetimePei,
                        totalClickPei: this.totalClickPei,
                        goldenPeiClick: this.goldenPeiClick,
                        ascensionCount: this.ascensionCount,
                        realityShards: this.realityShards,
                        totalRealityShards: this.totalRealityShards,
                        milk: this.milk,
                        sugar: this.sugar,
                        playTime: this.playTime,
                        totalPlayTime: this.totalPlayTime,
                        lastUpdateTime: Date.now(),
                        
                        buildings: this.buildings.map(b => ( b.quantity )),
                        upgrades: this.upgrades.map(u => ( u.unlocked )),
                        achievements: this.achievements.map(a => ( a.unlocked )),
                        ascendU: this.ascendU.map(au => ( au.level )),
                        // ...其他需要保存的数据...
                    };
                    console.log(saveData);
                    // 2. 转换为JSON字符串
                    const save= formatsave.encode(saveData)
                    console.log(save);
                    // 3. 显示给用户（示例）
                    navigator.clipboard.writeText(save);
                    alert("存档代码已复制到剪贴板");
                },
                loadGame() {
                    const save = prompt("请输入存档代码");
                        // 4. 解析JSON
                    const saveData = formatsave.decode(save);
                    transformToDecimal(saveData);
                        // 5. 应用存档数据
                    this.peiCount = saveData.peiCount;
                    this.thisAscendPei = saveData.thisAscendPei;
                    this.totalLifetimePei = saveData.totalLifetimePei;
                    this.totalClickPei = saveData.totalClickPei;
                    this.goldenPeiClick = saveData.goldenPeiClick;
                    this.ascensionCount = saveData.ascensionCount;
                    this.realityShards = saveData.realityShards;
                    this.totalRealityShards = saveData.totalRealityShards;
                    this.milk = saveData.milk;
                    this.sugar = saveData.sugar;
                    this.playTime = saveData.playTime;
                    this.totalPlayTime = saveData.totalPlayTime;

                    saveData.buildings.forEach((b, index) => {
                        this.buildings[index].quantity = b || N(0);
                    });
                    saveData.upgrades.forEach((u, index) => {
                        this.upgrades[index].unlocked = u || false;
                    });
                    saveData.achievements.forEach((a, index) => {
                        if(index >= this.achievements.length) return;
                        this.achievements[index].unlocked = a || false;
                    });
                    saveData.ascendU.forEach((au, index) => {
                        this.ascendU[index].level = au || N(0);
                    });
                        // 6. 离线生产
                    this.updateCost()
                    this.handleOfflineProduction(saveData.lastUpdateTime);
                    alert("存档加载成功！");
                },
                localSave() {
                    const saveData = {
                        peiCount: this.peiCount,
                        thisAscendPei: this.thisAscendPei,
                        totalLifetimePei: this.totalLifetimePei,
                        totalClickPei: this.totalClickPei,
                        goldenPeiClick: this.goldenPeiClick,
                        ascensionCount: this.ascensionCount,
                        realityShards: this.realityShards,
                        totalRealityShards: this.totalRealityShards,
                        milk: this.milk,
                        sugar: this.sugar,
                        playTime: this.playTime,
                        totalPlayTime: this.totalPlayTime,
                        lastUpdateTime: Date.now(),

                        buildings: this.buildings.map(b => ( b.quantity )),
                        upgrades: this.upgrades.map(u => ( u.unlocked )),
                        achievements: this.achievements.map(a => ( a.unlocked )),
                        ascendU: this.ascendU.map(au => ( au.level )),
                        // ...其他需要保存的数据...
                    };
                    localStorage.pelkieClickerSave = formatsave.encode(saveData);
                },
                localLoad() {
                    if (!localStorage.pelkieClickerSave) return;
                    const saveData = formatsave.decode(localStorage.pelkieClickerSave);
                    transformToDecimal(saveData);
                    this.peiCount = saveData.peiCount || N(0);
                    this.thisAscendPei = saveData.thisAscendPei || N(0);
                    this.totalLifetimePei = saveData.totalLifetimePei || N(0);
                    this.totalClickPei = saveData.totalClickPei || N(0);
                    this.goldenPeiClick = saveData.goldenPeiClick || 0;
                    this.ascensionCount = saveData.ascensionCount || N(0);
                    this.realityShards = saveData.realityShards || N(0);
                    this.totalRealityShards = saveData.totalRealityShards || N(0);
                    this.milk = saveData.milk || N(0);
                    this.sugar = saveData.sugar || N(0);
                    this.playTime = saveData.playTime || 0;
                    this.totalPlayTime = saveData.totalPlayTime || 0

                    saveData.buildings.forEach((b, index) => {
                        this.buildings[index].quantity = b || N(0);
                    });
                    saveData.upgrades.forEach((u, index) => {
                        this.upgrades[index].unlocked = u || false;
                    });
                    saveData.achievements.forEach((a, index) => {
                        if(index >= this.achievements.length) return;
                        this.achievements[index].unlocked = a || false;
                    });
                    saveData.ascendU.forEach((au, index) => {
                        this.ascendU[index].level = au || N(0);
                    });

                    this.updateCost();
                    this.handleOfflineProduction(saveData.lastUpdateTime);
                },
                hardReset() {
                    if (confirm("是否硬重置?这将重置你的所有进度!")) {
                        // 用户点击了确定
                        this.peiCount = N(0);
                        this.thisAscendPei = N(0);
                        this.totalLifetimePei = N(0);
                        this.totalClickPei = N(0);
                        this.peiPerSecond= N(0);
                        this.peiPerClick= N(1);
                        this.goldenPeiClick = 0;
                        this.goldenPeiTimer = 0;
                        this.goldenPeiEffects = {
                            clickMultiplier: N(1),
                            buildingMultiplier: N(1),
                            buildingCostReduction: N(1),
                            upgradeCostReduction: N(1),
                            randomBuildingBoost: null
                        };
                        this.buildings= Array.from({ length: 42 }, (_, i) => ({
                            id: i,
                            quantity: N(0),
                            baseCost: N(10).pow(i * (i - 1) / 40 + i + 1),
                            cost: N(10).pow(i * (i - 1) / 40 + i + 1),
                            baseProd: N(8).pow(i - 1),
                            production: N(8).pow(i - 1),
                        })),
                        this.upgrades= UPGRADES.map(u => ({
                                ...u,
                                unlocked: false,
                            })),
                        this.achievements= ACHIEVEMENTS.map(a => ({
                                ...a,
                                unlocked: false,
                            })),
                        this.ascendU= ASCENDU.map(r => ({
                                ...r,
                                unlocked: false,
                                level: N(0),
                            })),

                        this.ascensionCount = N(0);
                        this.realityShards = N(0);
                        this.totalRealityShards = N(0);

                        this.milk = N(0);
                        this.sugar = N(0);
                        this.playTime = N(0);
                        this.totalPlayTime = N(0);
                        this.lastUpdateTime= Date.now();

                        this.localSave();
                    }
                    else return;
                },
                handleOfflineProduction(savedTime) {
                    if (!savedTime) return;

                    const currentTime = Date.now();
                    const offlineTime = Math.min(currentTime - savedTime, this.ascendU[3].level.toNumber() * 21600000 + 21600000);
                    const offlineSeconds = offlineTime / 1000;

                    if (offlineSeconds > 1) {
                        // 计算离线收益
                        const production = this.totalProduction.mul(offlineSeconds);
                        this.peiCount = this.peiCount.add(production);
                        this.thisAscendPei = this.thisAscendPei.add(production);
                        this.totalLifetimePei = this.totalLifetimePei.add(production);
                        this.sugar = this.sugar.add(Math.floor(offlineSeconds / 3600));
                        this.playTime = this.playTime + (offlineSeconds % 3600);
                        this.totalPlayTime = this.totalPlayTime + offlineSeconds;
                        // 显示离线通知
                        this.showOfflineNotification(offlineSeconds, production);
                    }
                },
                showOfflineNotification(seconds, amount) {
                    const hours = Math.floor(seconds / 3600);
                    const mins = Math.floor((seconds % 3600) / 60);
                    const secs = Math.floor(seconds % 60);
                    const toast = document.createElement('div');
                    toast.className = 'offline-toast';
                    toast.innerHTML = `
                <p>你离线了 ${hours}h${mins}m${secs}s</p>
                <p>离线产量: ${this.format(amount.div(seconds).mul(0.8))}</p>
                <p>效率: 80%, 时长上限: ${this.ascendU[3].level.toNumber()*6+6}h</p>
                <p>获得 ${this.format(amount)} 佩干</p>
                <p>获得 ${this.formatInt(N(seconds / 3600))} 糖块</p>
            `;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 5000);
                },
                updateCost(){
                    for(let i=0;i<42;i++) this.buildings[i].cost = this.buildings[i].baseCost.mul(new Decimal(1.148698354997035).pow(this.buildings[i].quantity));
                    this.ascendU[0].cost = N(1);
                    this.ascendU[1].cost = N(3).add(this.ascendU[1].level.mul(667));
                    this.ascendU[2].cost = N(5).add(this.ascendU[2].level.mul(10));
                    this.ascendU[3].cost = N(7).pow(this.ascendU[3].level.add(1));
                    this.ascendU[4].cost = N(50).mul(N(100).pow(this.ascendU[4].level));
                    this.ascendU[5].cost = N(77).mul(N(10).pow(this.ascendU[5].level));
                    this.ascendU[6].cost = this.ascendU[6].level.add(1).mul(N(100).pow(this.ascendU[6].level.add(1)));
                    this.ascendU[7].cost = N(777).mul(N(10).pow(this.ascendU[7].level));
                    this.ascendU[8].cost = N(999).mul(N(100).pow(this.ascendU[8].level));
                    this.ascendU[9].cost = N(9000).mul(N(1e12).pow(this.ascendU[9].level));
                    this.ascendU[10].cost = N(99999).mul(N(2).pow(this.ascendU[10].level));
                    this.ascendU[11].cost = N(222222).add(this.ascendU[11].level.mul(2e6));
                    this.ascendU[12].cost = N(399999);
                    this.ascendU[13].cost = N(1.5e7);
                    this.ascendU[14].cost = N(1e8).mul(N(4).pow(this.ascendU[14].level));
                    this.ascendU[15].cost = N(2e8).mul(N(4).pow(this.ascendU[15].level));
                    this.ascendU[16].cost = N(1e9).mul(N(100).pow(this.ascendU[16].level))
                    this.ascendU[17].cost = N(2e9);
                    this.ascendU[18].cost = N(9e9).mul(N(1000).pow(this.ascendU[18].level));
                    this.ascendU[19].cost = N(3e10).mul(N(3).pow(this.ascendU[19].level));
                },
                // 其他方法...
            },
            computed: {
                // 带升级加成的总生产量
                sugarBonus(){
                    let sugarMult = this.sugar.mul(0.001).add(1);

                    return sugarMult;
                },
                milkBonus(){
                    let milkMult = this.upgrades.filter(u => u.buildingId == 102).reduce((prod, upgrade, i) => {
                        let factor = i < 8 ? i < 4 ? N(0.004).add(0.001 * i) : N(0.008) : i < 12 ? N(0.016).sub(0.001 * i) : N(0.004);
                        return upgrade.unlocked ? prod.mul(factor.mul(this.milk).add(1)) : prod;
                    }, N(1))
                    .mul(Decimal.pow(this.milk.mul(0.004).add(1), this.ascendU[9].level));

                    return milkMult;
                },
                upgradeBonus(){
                    let upgradeMult = this.upgrades.filter(u => u.buildingId == 105).reduce((sum, upgrade) => {
                        return upgrade.unlocked ? sum.mul(N(1).add(N(upgrade.id-1).add(10).div(10).floor().div(100))) : sum;
                    }, N(1))
                    .mul(this.upgrades.filter(u => u.buildingId == 104 & u.id>=6).reduce((sum, upgrade, i) => {
                        let factor=[1.01,1.1,2,11,101]
                        return upgrade.unlocked ? sum.mul(factor[i]) : sum;
                    }, N(1)))
                    .mul(Decimal.pow(1.1,this.ascendU[1].level))
                    .mul(this.enableGolden?N(1):this.ascendU[8].level.mul(0.1).add(1.4))
                    .mul(this.enableClick?N(1):this.ascendU[16].level.mul(0.1).add(1.4));
                    return upgradeMult;
                },
                ascendBonus(){
                    let ascendMult = this.upgrades.filter(u => u.buildingId == 104 & u.id<=5).reduce((sum, upgrade, i) => {
                        let factor=[0.05,0.2,0.25,0.25,0.25]
                        return upgrade.unlocked ? sum.add(this.totalRealityShards.mul(factor[i])) : sum;
                    }, N(1));

                    return ascendMult;
                },
                totalClick() {
                    let base = N(this.goldenPeiEffects.clickMultiplier);
                    let mult = this.upgrades.filter(u => u.buildingId == 1 && u.id < 4).reduce((prod, upgrade) => {
                        return upgrade.unlocked ? prod.mul(2) : prod;
                    }, N(1));
                    if (this.upgrades.filter(u => u.buildingId == 1 && u.id == 4)[0].unlocked) {
                        mult = mult.add(this.upgrades.filter(u => u.buildingId == 1 && u.id > 4).reduce((prod, upgrade) => {
                            return upgrade.unlocked ? prod.mul(20) : prod;
                        }, N(1)).mul(this.nonB1Count));
                    }
                    mult = mult.mul(this.upgrades.filter(u => u.buildingId == 101).reduce((prod, upgrade) => {
                        return upgrade.unlocked ? prod.mul(1.01) : prod;
                    }, N(1)));
                    return base.mul(mult).mul(this.sugarBonus).mul(this.milkBonus).mul(this.upgradeBonus).mul(this.ascendBonus).mul(this.goldenPeiEffects.buildingMultiplier);
                },
                totalProduction() {
                    let base = this.buildings.reduce((sum, building, index) => {
                        let buildingMult = N(1);
                        if (index == 0) {
                            buildingMult = this.upgrades.filter(u => u.buildingId == 1 && u.id < 4).reduce((prod, upgrade) => {
                                return upgrade.unlocked ? prod.mul(2) : prod;
                            }, N(1))
                            .mul(this.goldenPeiEffects.randomBuildingBoost == index ? 1.1 : 1);    ;
                            if (this.upgrades.filter(u => u.buildingId == 1 && u.id == 4)[0].unlocked) {
                                buildingMult = buildingMult.add(this.upgrades.filter(u => u.buildingId == 1 && u.id > 4).reduce((prod, upgrade) => {
                                    return upgrade.unlocked ? prod.mul(20) : prod;
                                }, N(1)).mul(this.nonB1Count));
                            }
                        }
                        if (index == 1) {
                            buildingMult = this.upgrades.filter(u => u.buildingId == 2).reduce((prod, upgrade) => {
                                return upgrade.unlocked ? prod.mul(2) : prod;
                            }, N(1))
                            .mul(this.upgrades.filter(u => u.buildingId == 103).reduce((prod, upgrade) => {
                                return upgrade.unlocked ? prod.mul(2) : prod;
                            }, N(1)))
                            .mul(this.goldenPeiEffects.randomBuildingBoost == index? 1.1:1);
                        }
                        if (index >= 2) {
                            buildingMult = this.upgrades.filter(u => u.buildingId == (index + 1)).reduce((prod, upgrade) => {
                                return upgrade.unlocked ? prod.mul(2) : prod;
                            }, N(1))
                                .mul(this.upgrades.filter(u => u.buildingId == 103 && u.id == index - 1)[0].unlocked ? N(1).add(this.buildings[1].quantity.div(index - 1).div(100)) : N(1))
                                .mul(this.goldenPeiEffects.randomBuildingBoost == index ? 1.1 : 1);
                        }
                        building.production = building.quantity.mul(building.baseProd).mul(buildingMult)
                        return sum.add(building.production);
                    }, N(0));
                    if (this.ascendU[1].level.gte(1)) base = base.mul(1.1);
                    return base.mul(this.milkBonus).mul(this.sugarBonus).mul(this.upgradeBonus).mul(this.ascendBonus).mul(this.goldenPeiEffects.buildingMultiplier);
                },
                nonB1Count() {
                    let sum = N(0);
                    for (i = 1; i < (this.buildings.length - 1); i++) sum = sum.add(this.buildings[i].quantity);
                    return sum;
                },
                unlockedUpgradesCount() {
                    return this.upgrades.filter(u => u.unlocked).length;
                },
                unlockedAchievementsCount() {
                    return this.achievements.filter(a => a.unlocked).length;
                },
                canAscend() {
                    return this.totalLifetimePei.gte(1e12);
                },
                canTranscend(){
                    return this.totalLifetimePei.gte(1e48);
                },
                canBreak(){
                    return this.totalLifetimePei.gte(Decimal.pow(1e16,this.breakCount).mul(1e192));
                },
                canHypercend(){
                    return this.totalLifetimePei.gte(1e308);
                },
                totalShards() {
                    return this.totalLifetimePei.gte(1e48) ? this.totalLifetimePei.pow(1 / 4).floor() : this.totalLifetimePei.div(1e12).pow(1 / 3).floor();
                },
                nextShards() {
                    return this.totalLifetimePei.gte(1e48) ? this.totalShards.add(1).pow(4) : this.totalShards.add(1).pow(3).mul(1e12);
                },
                totalTP(){
                    return this.totalLifetimePei.gte(1e192) ? this.totalLifetimePei.pow(1 / 16).floor() : this.totalLifetimePei.div(1e48).pow(1 / 12).floor();
                },
                nextTP(){
                    return this.totalLifetimePei.gte(1e192) ? this.totalShards.add(1).pow(16) : this.totalShards.add(1).pow(12).mul(1e48);
                }
            },
            mounted() {
                this.localLoad();
                // 游戏循环
                setInterval(() => {
                    // 使用computed属性计算生产量
                    this.peiPerClick = this.totalClick;
                    this.peiPerSecond = this.totalProduction;
                    this.peiCount = this.peiCount.add(this.totalProduction.div(50));
                    this.thisAscendPei = this.thisAscendPei.add(this.totalProduction.div(50));
                    this.totalLifetimePei = this.totalLifetimePei.add(this.totalProduction.div(50));
                }, 20);
                setInterval(() => {
                    this.goldenPeiTimer++
                    this.playTime++;
                    this.totalPlayTime++;
                    let sugarTimer = 3600;
                    if (this.playTime >= sugarTimer) {
                        this.sugar = this.sugar.add(1);
                        this.playTime = 0;
                    }
                    let t = this.upgrades.filter(u => u.buildingId == 107 && u.id == 1)[0].unlocked ? 210 : 420;
                    let l = this.upgrades.filter(u => u.buildingId == 107 && u.id == 1)[0].unlocked ? 26 : 13;
                    t=t/(this.ascendU[5].level.mul(0.1).add(1).toNumber());
                    if (this.goldenPeiTimer >= t) {
                        this.goldenPeiVisible = true;
                        setTimeout(() => {
                            this.goldenPeiVisible = false;
                        }, 1000*l);
                        this.goldenPeiTimer = 0;
                    }
                    this.checkAchievements(101);
                }, 1000);
                setInterval(() => {
                    this.localSave();
                },10000)
            }
        });
    </script>
</body>
</html>