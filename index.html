<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>佩乐点点勒</title>
    <script type="text/javascript" src="vue.js"></script>
    <script type="text/javascript" src="pako.js"></script>
    <script type="text/javascript" src="break_infinity.js"></script>
    <style>
        body {
            text-align: center;
            font-family: MonospaceTypewriter, monospace;
        }

        button {
            text-align: center;
            font-family: MonospaceTypewriter, monospace;
            font-size: 16px;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            max-width: 540px;
        }

        .tabs {
            display: grid;
            grid-template-columns: repeat(4, minmax(130px,1fr)); /* 4列 */
            grid-auto-rows: minmax(40px, auto); /* 行高 */
            gap: 5px; /* 间距 */
            margin: 10px 0;
        }

        .tab {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
            font-size: 16px;
        }

        /* 响应式适配 */
        @media (max-width: 540px) {
            .tabs {
                grid-template-columns: repeat(4, minmax(60px,1fr));
            }

            .tab {
                font-size: 16px;
                padding: 5px;
            }
        }

        .active-tab {
            background-color: #f0f0f0;
        }

        .clickable {
            cursor: pointer;
        }

        .click-effects-container {
            position: relative;
            bottom: -50%;
            left: 30%;
            right: 0;
            pointer-events: none;
        }

        .click-effect {
            position: absolute;
            font-size: 16px;
            color: #114514;
            font-weight: bold;
            animation: floatUp 2s ease-out forwards;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-100px);
                opacity: 0;
            }
        }

        /* 响应式调整 */
        @media (max-width: 540px) {
            .big-pei {
                font-size: 80px;
            }

            .click-effect {
                font-size: 18px;
            }
        }

        .golden-pei {
            width: 50px;
            height: 50px;
            background-color: gold;
        }

        .golden-pei-hide {
            width: 50px;
            height: 50px;
            background-color: #cccccc;
        }

        .effect-toast {
            position: fixed;
            right: 20px;
            bottom: 20px;
            background: #fff3e0;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-left: 5px solid #ff9800;
            animation: slideIn 0.3s ease-out;
        }

        .disabled {
            background-color: #ccc;
        }

        .building-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 1fr);
        }

        .building {
            border: 2px solid #ccc;
            border-radius: 8px;
            padding: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between; /* 添加这行 */
            background: #f8f8f8;
        }

        .bulk-selector {
            margin: 10px 0;
            padding: 5px;
            background: #f0f0f0;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 1fr);
        }

        .upgrade {
            border: 2px solid #ccc;
            border-radius: 4px;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between; /* 添加这行 */
            background: #f8f8f8;
        }

        .achievement-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 1fr);
        }

        .achievement {
            border: 2px solid #ccc;
            border-radius: 4px;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #f8f8f8;
        }

            .achievement.unlocked {
                border-color: #4CAF50;
                background: #e8f5e9;
            }

        .achievement-icon {
            font-size: 2em;
            margin-right: 15px;
        }

        .achievement-info h4 {
            margin: 0 0 5px 0;
            color: #333;
        }

        .achievement-info p {
            margin: 0;
            color: #666;
        }

        .achievement-info small {
            color: #999;
            font-size: 0.8em;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
            }

            to {
                transform: translateX(0);
            }
        }

        .achievement-toast {
            position: fixed;
            right: 20px;
            bottom: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            animation: slideIn 0.3s ease-out;
            border-left: 5px solid #4CAF50;
        }

        .shop {
            margin-top: 20px;
            border-top: 2px solid #666;
            padding-top: 15px;
        }

        .upgrade-item {
            border: 1px solid #aaa;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            background: #f8f8f8;
        }

            .upgrade-item button {
                margin: 5px 0;
            }

        .offline-toast {
            position: fixed;
            right: 20px;
            bottom: 80px;
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-left: 5px solid #2196F3;
            animation: slideIn 0.3s ease-out;
        }
    </style>
</head>
<body>
    <div id="app" class="container">
        <h1>你有 {{ format(peiCount) }} 佩干</h1>

        <h3>{{ format(peiPerSecond) }}/秒 {{ format(peiPerClick) }}/点击</h3>

        <div class="clickable" @click="clickPei" style="width: 200px; height: 200px; background-image: url('pelkie.bmp')">
            <div class="click-effects-container">
                <div v-for="(effect, index) in clickEffects"
                     :key="index"
                     :style="effect.style"
                     class="click-effect">
                    +{{ format(effect.amount) }}
                </div>
            </div>
        </div>

        <div :class="goldenPeiVisible?'golden-pei clickable':'golden-pei-hide'" @click="clickGoldenPei" style="font-size:36px; text-align:center">♅</div>

        <div class="bonus-status">
            <div>牛奶: {{ format(milk) }}</div>
            <div>糖块: {{ format(sugar) }}</div>
        </div>

        <div>金佩勒效果: {{effect}}</div>

        <div class="tabs">
            <div v-for="(tab, index) in tabs" :key="index"
                 class="tab clickable"
                 :class="{ 'active-tab': currentTab === index }"
                 @click="currentTab = index">
                {{ tab }}
            </div>
        </div>

        <!-- 建筑选项卡 -->
        <div v-if="currentTab === 0">
            <div class="bulk-selector">
                购买数量:
                <select v-model="bulkAmount">
                    <option value="1">×1</option>
                    <option value="10">×10</option>
                    <option value="100">×100</option>
                    <option value="1000">×1000</option>
                    <option value="10000">×10000</option>
                    <option value="100000">×100000</option>
                    <option value="1000000">×1000000</option>
                </select>
            </div>
            <div class="building-grid">
                <div style="line-height:0px; color:white">------------------------------------------------------------</div>
                <div v-for="(building, index) in buildings" :key="index" class="building">
                    &nbsp;&nbsp;建筑{{ building.id + 1 }}&nbsp;&nbsp;<br />
                    &nbsp;&nbsp;数量:{{ formatInt(building.quantity) }}&nbsp;&nbsp;<br />
                    &nbsp;&nbsp;基础佩干/秒:{{ format(building.baseProd) }}&nbsp;&nbsp;<br />
                    &nbsp;&nbsp;佩干/秒:{{ format(building.production) }}&nbsp;&nbsp;
                    <button @click="buyBuilding(index)"
                            :disabled="peiCount.lt(calcBulkCost(index))">
                        购买 ×{{ bulkAmount }}<br />
                        花费 {{ format(calcBulkCost(index)) }} 佩干
                    </button>
                </div>
            </div>
        </div>

        <!-- 升级选项卡 -->
        <div v-if="currentTab === 1">
            <div style="font-size:24px">升级 ({{ unlockedUpgradesCount }}/{{ upgrades.length }})</div>
            <div class="upgrade-grid">
                <div>--------------------------------------------------------</div>
                <div v-for="upgrade in upgrades"
                     :key="upgrade.buildingId*100+upgrade.id"
                     v-if="!upgrade.unlocked && ((upgrade.buildingId<100 && buildings[upgrade.buildingId-1].quantity.gte(upgrade.required)) || (upgrade.buildingId==101 && totalClickPei.gte(upgrade.required)) || (upgrade.buildingId==102 && N(unlockedAchievementsCount).gte(upgrade.required)) || (upgrade.buildingId==103 && buildings[upgrade.id+1].quantity.gte(upgrade.required)) || (upgrade.buildingId==104 && totalRealityShards.gte(1)) || (upgrade.buildingId==105 && ascendU[2].level.gte(upgrade.required)) || (upgrade.buildingId==777 && goldenPeiClick>=upgrade.required) )"
                     class="upgrade">
                    <div>
                        升级{{ upgrade.buildingId }}-{{ upgrade.id }}
                        <span v-show="upgrade.buildingId==1 & upgrade.id<4">点击和建筑 1 生产的佩干×2&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId==1 & upgrade.id==4">每个建筑 2~42 使点击和建筑 1 生产的佩干+0.2&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId==1 & upgrade.id>4">升级1-4的效果×20&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId<100 & upgrade.buildingId>1">建筑 {{upgrade.buildingId}} 的产量×2&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId==101">点击获得的佩干 +1% <del>每秒生产的佩干</del></span>
                        <span v-show="upgrade.buildingId==102">释放牛奶力量(叠乘)，佩干每秒×(1+牛奶*{{format(upgrade.id < 8 ? upgrade.id < 4 ? N(0.004).add(0.001 * upgrade.id) : N(0.008) : upgrade.id < 12 ? N(0.016).sub(0.001 * upgrade.id) : N(0.004))}})&nbsp;&nbsp;</span>
                        <span v-show="upgrade.buildingId==103">建筑 2 的产量×2, 建筑 {{upgrade.id+2}} 的产量 +1% 每拥有 {{upgrade.id}} 个建筑2 </span>
                        <span v-show="upgrade.buildingId==104 & upgrade.id<6">每个累计的现实碎片使佩干产量 +{{Math.max(5,upgrade.id*25-25)}}%</span>
                        <span v-show="upgrade.buildingId==104 & upgrade.id==6">佩干产量乘数 +1%</span>
                        <span v-show="upgrade.buildingId==104 & upgrade.id==7">佩干产量乘数 +10%</span>
                        <span v-show="upgrade.buildingId==105">佩干产量乘数 +{{Math.floor((upgrade.id-1)/10)+1}}%</span>
                        <span v-show="upgrade.buildingId==777 & upgrade.id==1">金佩勒出现频率翻倍，在屏幕上的持续时间翻倍</span>
                        <span v-show="upgrade.buildingId==777 & upgrade.id==2"><del>金佩勒出现频率翻倍，在屏幕上的持续时间翻倍</del>(被佩勒删除)</span>
                        <span v-show="upgrade.buildingId==777 & upgrade.id==3"><del>金佩勒效果的持续时间翻倍</del>(被佩勒删除)</span>
                    </div>
                    <button @click="buyUpgrade(upgrade.id, upgrade.buildingId)"
                            :disabled="!canBuyUpgrade(upgrade.id, upgrade.buildingId)">
                        {{ format(upgrade.cost.mul(goldenPeiEffects.upgradeCostReduction)) }} 佩干
                    </button>
                </div>
            </div>
        </div>

        <!-- 成就选项卡 -->
        <div v-if="currentTab === 2">
            <div style="font-size:24px">成就 ({{ unlockedAchievementsCount }}/{{ achievements.length }})</div>
            <div class="achievement-grid">
                <div>--------------------------------------------------------</div>
                <div v-for="achievement in achievements" :key="achievement.buildingId*100+achievement.id" class="achievement" :class="{ 'unlocked': achievement.unlocked }">
                    <div class="achievement-info">
                        {{ achievement.unlocked ? '√' : '×' }} 成就{{ achievement.buildingId }}-{{ achievement.id }}
                        <span v-show="achievement.buildingId<100">拥有 {{formatInt(achievement.required)}} 个建筑 {{achievement.buildingId}}</span>
                        <span v-show="achievement.buildingId==101">累计获得 {{format(achievement.required)}} 个佩干</span>
                        <span v-show="achievement.buildingId==102">每秒生产 {{format(achievement.required)}} 个佩干</span>
                        <span v-show="achievement.buildingId==103">点击获得 {{format(achievement.required)}} 个佩干</span>
                        <span v-show="achievement.buildingId==104">累计获得 {{format(achievement.required)}} 个现实碎片</span>

                    </div>
                </div>
            </div>
        </div>

        <!-- 飞升选项卡 -->
        <div v-if="currentTab === 3">
            <div v-if="canAscend">
                <p>飞升获取 {{ format(this.totalShards.sub(this.totalRealityShards).max(0)) }} 现实碎片 (下一个在 {{format(nextShards)}} 佩干)</p>
                <button @click="ascend">Ascend!</button>
            </div>
            <div v-else>
                <p>飞升(ascend)需要 1e12 累计佩干 ({{ format(totalLifetimePei) }}/1e12)</p>
            </div>

            <div class="shop">
                <h4>飞升升级 (你有 {{ format(realityShards) }}/{{format(totalRealityShards)}} 现实碎片)</h4>
                <div v-for="upgrade in ascendU" :key="upgrade.id" class="upgrade-item" v-if="upgrade.id<5">
                    {{auDescription[upgrade.id-1]}}<br />
                    等级 {{ formatInt(upgrade.level) }}/{{ formatInt(upgrade.maxLevel) }}
                    <button @click="buyAscendU(upgrade.id-1)"
                            :disabled="realityShards.lt(upgrade.cost)">
                        {{ format(upgrade.cost) }} RS
                    </button>
                </div>
            </div>
        </div>

        <!-- 超越选项卡 -->
        <div v-if="currentTab === 4">

            <div>
                <p>超越(transcend)获取超越碎片(需要1e48)</p>
            </div>

        </div>
        <!-- 高产选项卡 -->
        <div v-if="currentTab === 5">

            <div>
                <p>觉醒(hypercend)获取觉醒碎片(需要1e192累计佩干)</p>
            </div>

        </div>
        <!-- 统计选项卡 -->
        <div v-if="currentTab === 6">
            <h3>统计:</h3>
            <div>当前佩干: {{format(peiCount)}}</div>
            <div>本次飞升中的佩干: {{format(thisAscendPei)}}</div>
            <div>累计佩干: {{format(totalLifetimePei)}}</div>
            <div>佩干每秒: {{format(peiPerSecond)}}</div>
            <div>点击获得的佩干: {{format(totalClickPei)}}</div>
            <div>佩干每次点击: {{format(peiPerClick)}}</div>

            <div>飞升次数: {{format(ascensionCount)}}</div>
            <div>当前现实碎片: {{format(realityShards)}}</div>
            <div>累计现实碎片: {{format(totalRealityShards)}}</div>

            <div>游戏时间: {{ Math.floor(totalPlayTime) }}</div>
            <div>糖块计时: {{ Math.floor(playTime) }}/3600</div>
            <div>牛奶乘数: x{{ format(milkBonus) }}</div>
            <div>糖块乘数: x{{ format(sugarBonus) }}</div>
            <div>飞升乘数: x{{ format(ascendBonus) }}</div>
            <!-- 原有统计信息... -->
        </div>
        <!-- 存档选项卡 -->
        <div v-if="currentTab === 7">
            <button @click="saveGame()">导出</button>
            <button @click="loadGame()">导入</button>
            <button @click="hardReset()" style="color:red">硬重置</button>
            <div>
                Pelle把你的饼干变成了佩勒饼干，你无法逃离被毁灭的饼干宇宙，你几乎在整个游戏中都会受到重大削弱。
                削弱:<br />
                风味饼干升级被删除（天堂升级和建筑数量相关的除外）<br />
                删除研究中心<br />
                删除老奶奶末世<br />
                删除季节<br />
                删除小游戏<br />
                协同升级效果被修改<br />
                无法用糖块升级建筑<br />
                移除了一些飞升升级<br />
                移除了一些成就<br />
                金饼干效果中的"7"变成"6"<br />
                升级和效果中的一些文字被删除<br />
                天堂碎片在1e12后被软上限:x^(1/3)/1e12→x^1/4<br />
                增强:<br />
                声望等级效果x100<br />
                被动糖块乘数但效果倍率/10<br />
                新增22个建筑<br />
                一开始就有6小时80%的离线收益<br />
                新声望层级:超越,在1e48累计饼干后解锁<br />
                新声望层级:觉醒,在1e192累计饼干后解锁<br />
            </div>
        </div>
    </div>

    <script>
        var formatsave = {
            encoder: new TextEncoder(),
            decoder: new TextDecoder(),
            startString: 'PelkieClickerSaveFormat',
            endString: 'EndOfSaveFile',
            steps: [{
                encode: JSON.stringify,
                decode: JSON.parse
            },
            {
                encode: x => formatsave.encoder.encode(x),
                decode: x => formatsave.decoder.decode(x)
            },
            {
                encode: x => pako.deflate(x),
                decode: x => pako.inflate(x)
            },
            {
                encode: x => Array.from(x).map(i => String.fromCharCode(i)).join(""),
                decode: x => Uint8Array.from(Array.from(x).map(i => i.charCodeAt(0)))
            },
            {
                encode: x => btoa(x),
                decode: x => atob(x)
            },
            {
                encode: x => x.replace(/=+$/g, "").replace(/0/g, "0a").replace(/\+/g, "0b").replace(/\//g, "0c"),
                decode: x => x.replace(/0b/g, "+").replace(/0c/g, "/").replace(/0a/g, "0")
            },
            {
                encode: x => formatsave.startString + x + formatsave.endString,
                decode: x => x.slice(formatsave.startString.length, -formatsave.endString.length),
            }
            ],
            encode(s) {
                return this.steps.reduce((x, f) => f.encode(x), s);
            },
            decode(s) {
                return this.steps.reduceRight((x, f) => f.decode(x), s);
            },
        }

        function transformToDecimal(object) {
            for (i in object) {
                if (typeof (object[i]) == 'string' && !isNaN(N(object[i]).m)) object[i] = N(object[i]);
                if (typeof (object[i]) == 'object') transformToDecimal(object[i]);
            }
        }

        function data_print() {
            localStorage.PelkieClickerSave = formatsave.encode(JSON.stringify(data));
        }

        function data_input() {
            if (!localStorage.PelkieClickerSave) return;
            if (localStorage.PelkieClickerSave[0] == 'e') data = JSON.parse(atob(localStorage.PelkieClickerSave));
            else data = JSON.parse(formatsave.decode(localStorage.PelkieClickerSave));
            transformToDecimal(data);
        }

        async function jtb(text) {
            try {
                await navigator.clipboard.writeText(text);
                console.log('Text copied to clipboard');
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }

        function export_save() {
            jtb(formatsave.encode(JSON.stringify(data)));
        }

        function import_save() {
            let userInput = prompt("导入：", "输入存档");
            if (userInput != null && userInput !== "") {
                if (userInput[0] == 'e') data = JSON.parse(atob(userInput));
                else data = JSON.parse(formatsave.decode(userInput));
                transformToDecimal(data);
                data_print();
                location.reload();
            } else {
            }
        }

        function N(num) {
            return new Decimal(num);
        }
        const UPGRADES = (() => {
            const upgrades = [];
            upgrades.push({
                id: 0,
                buildingId: 1,
                required: N(0),
                cost: N(40),
            })
            //升级1~1050:建筑乘数升级
            for (let i = 1; i <= 1050; i++) {
                let index = (i-1) % 25 + 1;
                let bIndex = Math.floor((i-1) / 25);
                let costMult = [10,50,500,10000,1e7,1e10,1e13,1e16,1e19,1e22,1e25,1e28,1e31,1e34,1e37,1e40,1e43,1e49,1e55,1e61,1e97,1e150,1e240,'1e400','1e600'];
                let requirement = [1,5,25,50,100,150,200,250,300,350,400,450,500,550,600,650,700,800,900,1000,1600,2500,4000,6500,10000];
                upgrades.push({
                    id: index,
                    buildingId: bIndex+1,
                    required: N(requirement[index-1]),
                    cost: N(costMult[index-1]).mul(Math.pow(10, bIndex * (bIndex - 1) / 40 + bIndex + 1)),
                })
            }
            //升级1051~1075:点击乘数
            for (let i = 1; i <= 20; i++) {
                upgrades.push({
                    id: i,
                    buildingId: 101,
                    required: N(100).pow(i),
                    cost: N(100).pow(i).mul(5),
                })
            }
            //升级1075~1100:牛奶乘数
            for (let i = 1; i <= 40; i++) {
                upgrades.push({
                    id: i,
                    buildingId: 102,
                    required: i==1?N(10):N(25).mul(i-1),
                    cost: N(1000).pow(i).mul(9000),
                })
            }
            //升级1101~1140:建筑2协同
            for (let i = 1; i <= 40; i++) {
                upgrades.push({
                    id: i,
                    buildingId: 103,
                    required: N(20),
                    cost: N(Math.pow(10, i * (i - 1) / 40 + i + 1)).mul(200),
                })
            }
            //升级1141~1150:飞升效果
            for (let i = 1; i <= 7; i++) {
                let costs = [11, 1111, 111111, 11111111, 1111111111, 100, 1e12, 1e22, 1e32, 1e42];
                upgrades.push({
                    id: i,
                    buildingId: 104,
                    required: i,
                    cost: N(costs[i-1]),
                })
            }
            //升级1151~1200:飞升升级佩干
            for (let i = 1; i <= 80; i++) {
                let costs = [];
                upgrades.push({
                    id: i,
                    buildingId: 105,
                    required: N(Math.floor((i-1)/10)+1),
                    cost: N(1e10).mul(N(2).pow(i)),
                })
            }
            //升级1201~1250:飞升团结I升级
            //升级1251~1300:飞升团结II升级
            upgrades.push({
                id: 1,
                buildingId: 777,
                required: 7,
                cost: N(777777777),
            })//金佩乐出现频率加倍且持续时间加倍. other 2 upgrades are deleted by pelle.
            upgrades.push({
                id: 2,
                buildingId: 777,
                required: 27,
                cost: N(77777777777),
            })
            upgrades.push({
                id: 3,
                buildingId: 777,
                required: 77,
                cost: N(77777777777777),
            })
            return upgrades;
        })();
        const ACHIEVEMENTS = (() => {
            const achievements = [];
            //成就 :累计获得的佩干数量
            for (let i = 1; i <= 25; i++) {
                let targetT = i <= 16 ? N(100).pow(i) : N(10).pow(N(10).pow(i - 15));
                achievements.push({
                    id: i,
                    buildingId: 101,
                    required: targetT,
                })
            }
            //成就 :每秒获得的佩干数量
            for (let i = 1; i <= 25; i++) {
                let targetS = i <= 16 ? N(10).pow(i) : N(10).pow(N(10).pow(i - 15));
                achievements.push({
                    id: i,
                    buildingId: 102,
                    required: targetS,
                })
            }
            //成就 :点击获得的佩干数量
            for (let i = 1; i <= 25; i++) {
                let targetC = i <= 16 ? N(100).pow(i) : N(10).pow(N(10).pow(i - 15));
                achievements.push({
                    id: i,
                    buildingId: 103,
                    required: targetC,
                })
            }
            //成就 :拥有的建筑数量
            for (let i = 1; i <= 1050; i++) {
                let target = [1,50,100,150,200,250,300,350,400,450,500,600,700,800,900,1000,2000,3000,4000,5000,6000,7000,8000,9000,10000];
                achievements.push({
                    id: (i  -1) % 25 + 1,
                    buildingId: Math.floor((i-1)/25) + 1,
                    required: N(target[(i - 1) % 25]),
                })
            }
            //成就 :飞升层级成就
            for (let i = 1; i <= 15; i++) {
                let targetR = N(10).pow(i-1);
                achievements.push({
                    id: i,
                    buildingId: 104,
                    required: targetR,
                })
            }
            //成就 :超越层级成就
            //成就 :高产层级成就
            //成就 :其他
            return achievements;
        })();
        const ASCENDU = (() => {
            const ascendU = [];
            ascendU.push({ id: 1, cost: N(1), maxLevel: N(1) });//解锁飞升系统
            ascendU.push({ id: 2, cost: N(3), maxLevel: N(3) });//佩干产量乘数+10% 3,6e6,9e12
            ascendU.push({ id: 3, cost: N(5), maxLevel: N(5) });//解锁风味佩干 5+n*10
            ascendU.push({ id: 4, cost: N(7), maxLevel: N(7) });//离线时长 7^(n+1)
            ascendU.push({ id: 5, cost: N(50), maxLevel: N(2) });//初始拥有10建筑1或2 50*10^2n
            ascendU.push({ id: 6, cost: N(77), maxLevel: N(10) });//金佩干出现频率提升10% 77*10^2n
            ascendU.push({ id: 7, cost: N(100), maxLevel: N(5) });//背包 n*10^2n
            ascendU.push({ id: 8, cost: N(777), maxLevel: N(10) });//金佩干技能时间提升10% 777*10^2n
            ascendU.push({ id: 9, cost: N(999), maxLevel: N(6) });//禁用金佩干，pps+40+10等级% 999*10^3n
            ascendU.push({ id: 10, cost: N(9000), maxLevel: N(2) });//牛奶效果加成
            ascendU.push({ id: 11, cost: N(99999), maxLevel: N(10) });//建筑、升级价格降低1% 99999*10^5n
            ascendU.push({ id: 12, cost: N(222222), maxLevel: N(2) });//解锁协同升级，当拥有15和75个建筑时出现
            ascendU.push({ id: 13, cost: N(399999), maxLevel: N(1) });//升级价格除以5
            ascendU.push({ id: 14, cost: N(1.5e7), maxLevel: N(1) });//1-6到1-20的乘数变为1000
            ascendU.push({ id: 15, cost: N(1e8), maxLevel: N(10) });//糖块生长10%更快
            ascendU.push({ id: 16, cost: N(3e8), maxLevel: N(10) });//释放糖块力量
            ascendU.push({ id: 17, cost: N(1e9), maxLevel: N(6) });//禁用点击，pps+40+10等级% 10^(2n+9)
            ascendU.push({ id: 18, cost: N(2e9), maxLevel: N(1) });//建筑2升级变为x4
            ascendU.push({ id: 19, cost: N(9e9), maxLevel: N(5) });//牛奶价格降低10%
            ascendU.push({ id: 20, cost: N(3.2e10), maxLevel: N(40) });//解锁不受束缚的升级
            return ascendU;
        })();
        new Vue({
            el: '#app',
            data: {
                currentTab: 0,
                tabs: ['建筑', '升级', '成就', '飞升', '超越', '觉醒', '统计', '存档'],
                peiCount: N(0),
                thisAscendPei: N(0),
                totalLifetimePei: N(0),
                totalClickPei: N(0),
                peiPerSecond: N(0),
                peiPerClick: N(0),
                bulkAmount: 1,
                goldenPeiClick: 0,
                goldenPeiTimer: 0,
                goldenPeiVisible: false,
                goldenPeiEffects: {
                    clickMultiplier: N(1),
                    buildingMultiplier: N(1),
                    buildingCostReduction: N(1),
                    upgradeCostReduction: N(1),
                    randomBuildingBoost: null
                },
                effect: `无`,
                activeEffects: [],
                effectTimers: {},
                clickEffects: [],

                buildings: Array.from({ length: 42 }, (_, i) => ({
                    id: i,
                    quantity: N(0),
                    baseCost: N(10).pow(i * (i - 1) / 40 + i + 1),
                    cost: N(10).pow(i * (i - 1) / 40 + i + 1),
                    baseProd: N(8).pow(i - 1),
                    production: N(8).pow(i - 1),
                })),
                upgrades: UPGRADES.map(u => ({
                    ...u,
                    unlocked: false,
                })),
                achievements: ACHIEVEMENTS.map(a => ({
                    ...a,
                    unlocked: false,
                })),

                ascensionCount: N(0),
                realityShards: N(0),
                totalRealityShards: N(0),
                ascendBonus: N(1),
                ascendU: ASCENDU.map(r => ({
                    ...r,
                    unlocked: false,
                    level: N(0),
                })),
                auDescription: [
                    "神啊！（解锁飞升系统和升级）",
                    "一个残余物（佩干产量乘数+10%）",
                    "佩勒的5个裂隙（每级解锁10种风味佩干）",
                    "6小时后更新（离线生产增加6小时）",
                    "每次飞升保留10建筑{等级}",
                    "每级使金佩勒出现频率提升10%",
                    "解锁背包，背包中的升级在飞升时不会重置，每级解锁1个格子",
                    "每级使金佩勒技能时间提升10%",
                    "可以选择禁用黄金佩干，获得等级*10+40%佩干产量提升",
                    "释放牛奶力量，佩干产量×(1+0.004×牛奶)",
                    "建筑和升级的价格降低1%",
                    "每级解锁40个协同升级，需要15或75个对应建筑",
                    "升级的价格除以5",
                    "升级1-6到1-20的乘数变为1000",
                    "每级使糖块生长的速度增加10%",
                    "释放糖块力量，佩干产量×(1+0.004×等级×糖块)",
                    "可以选择禁用点击，获得等级*10+40%佩干产量提升",
                    "建筑2产量提升的升级效果变为x4",
                    "牛奶价格降低10%",
                    "解锁不受束缚的升级",
                ],

                milk: N(0),
                milkBonus: N(1),
                sugar: N(0),
                sugarBonus: N(1),
                playTime: N(0),
                totalPlayTime: N(0),
                lastUpdateTime: Date.now(),
                // 其他数据...
            },
            methods: {
                clickPei() {
                    this.peiCount = this.peiCount.add(this.peiPerClick);
                    this.totalClickPei = this.totalClickPei.add(this.peiPerClick);
                    this.totalLifetimePei = this.totalLifetimePei.add(this.peiPerClick);
                    this.addClickEffect(this.peiPerClick);
                    // 检查成就
                    this.checkAchievements(103);
                },
                addClickEffect(amount) {
                    const effect = {
                        amount: amount,
                        style: {
                            animationDuration: `2s` // 不随机速度
                        }
                    };
                    this.clickEffects.push(effect);

                    // 1秒后移除效果
                    setTimeout(() => {
                        this.clickEffects = this.clickEffects.filter(e => e !== effect);
                    }, 2000);
                },
                clickGoldenPei() {
                    if (!this.goldenPeiVisible) return;
                    this.goldenPeiClick++;
                    const effects = [
                        {
                            name: '获得15<del>分钟</del>产量的佩干',
                            chance: 9,
                            apply: () => this.gainProduction(15)
                        },
                        {
                            name: '获得的佩干×6，持续66秒',
                            chance: 6,
                            apply: () => this.applyBuildingMultiplier(6, 66)
                        },
                        {
                            name: '点击获得的佩干×666，持续13秒',
                            chance: 6,
                            apply: () => this.applyClickMultiplier(666, 13)
                        },
                        {
                            name: '随机建筑提升佩干产量<del>，基于其数量的</del>10%，持续30秒',
                            chance: 4,
                            apply: () => this.boostRandomBuilding(1.1, 30)
                        },
                        {
                            name: '获得的佩干×15，持续30秒',
                            chance: 3,
                            apply: () => this.applyBuildingMultiplier(15, 30)
                        },
                        {
                            name: '点击获得的佩干×1111，持续8秒',
                            chance: 3,
                            apply: () => this.applyClickMultiplier(1111, 8)
                        },
                        {
                            name: '建筑价格-50%，持续5秒',
                            chance: 2,
                            apply: () => this.applyBuildingCostReduction(0.5, 5)
                        },
                        {
                            name: '升级价格-50%，持续5秒',
                            chance: 2,
                            apply: () => this.applyUpgradeCostReduction(0.5, 5)
                        },
                        {
                            name: '获得1个糖块',
                            chance: 1,
                            apply: () => this.gainCandy()
                        },
                    ];
                    const allEffects = [...effects];
                    const selectedEffect = this.selectRandomEffect(allEffects);
                    selectedEffect.apply();
                    this.goldenPeiVisible = false;
                    this.showEffectNotification(selectedEffect.name);
                },
                applyClickMultiplier(multiplier, duration) {
                    this.goldenPeiEffects.clickMultiplier = N(multiplier);
                    this.startEffectTimer('clickMultiplier', () => {
                        this.goldenPeiEffects.clickMultiplier = N(1);
                    }, duration * 1000);
                },
                applyBuildingMultiplier(multiplier, duration) {
                    this.goldenPeiEffects.buildingMultiplier = N(multiplier);
                    this.startEffectTimer('buildingMultiplier', () => {
                        this.goldenPeiEffects.buildingMultiplier = N(1);
                    }, duration * 1000);
                },
                applyBuildingCostReduction(factor, duration) {
                    this.goldenPeiEffects.buildingCostReduction = N(factor);
                    this.startEffectTimer('buildingCostReduction', () => {
                        this.goldenPeiEffects.buildingCostReduction = N(1);
                    }, duration * 1000);
                },
                applyUpgradeCostReduction(factor, duration) {
                    this.goldenPeiEffects.upgradeCostReduction = N(factor);
                    this.startEffectTimer('upgradeCostReduction', () => {
                        this.goldenPeiEffects.upgradeCostReduction = N(1);
                    }, duration * 1000);
                },
                boostRandomBuilding(multiplier, duration) {
                    const buildingsWithQuantity = this.buildings.filter(b => b.quantity.gt(0));
                    if (buildingsWithQuantity.length === 0) return;
                    const randomBuilding = buildingsWithQuantity[
                        Math.floor(Math.random() * buildingsWithQuantity.length)
                    ];

                    this.goldenPeiEffects.randomBuildingBoost = randomBuilding.id;

                    this.startEffectTimer('randomBuildingBoost', () => {
                        this.goldenPeiEffects.randomBuildingBoost = null;
                    }, duration * 1000);
                },
                gainProduction(seconds) {
                    const production = this.peiPerSecond.mul(seconds);
                    this.peiCount = this.peiCount.add(production);
                },
                gainClicks(count) {
                    const total = this.peiPerClick.mul(count);
                    this.peiCount = this.peiCount.add(total);
                },
                gainCandy() {
                    this.sugar = this.sugar.add(1);
                },
                selectRandomEffect(effects) {
                    const totalWeight = effects.reduce((sum, e) => sum + e.chance, 0);
                    let random = Math.random() * totalWeight;
                    for (const effect of effects) {
                        if (random < effect.chance) return effect;
                        random -= effect.chance;
                    }
                    return effects[0];
                },
                startEffectTimer(name, callback, duration) {
                    if (this.effectTimers[name]) {
                        clearTimeout(this.effectTimers[name]);
                    }
                    this.effectTimers[name] = setTimeout(() => {
                        callback();
                        delete this.effectTimers[name];
                    }, duration);
                },
                showEffectNotification(effectName) {
                    this.effect = effectName;
                    const toast = document.createElement('div');
                    toast.className = 'effect-toast';
                    toast.innerHTML = `
                        <span>获得金佩勒效果:${effectName}</span>
            `       ;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 5000);
                },
                buyBuilding(index) {
                    const building = this.buildings[index];
                    const amount = parseInt(this.bulkAmount);
                    const totalCost = this.calcBulkCost(index);
                    if (this.peiCount.lt(totalCost)) return;
                    // 执行购买
                    this.peiCount = this.peiCount.sub(totalCost);
                    building.quantity = building.quantity.add(amount);
                    // 更新下次购买价格（使用公式代替循环）
                    building.cost = building.baseCost.mul(new Decimal(1.148698354997035).pow(building.quantity));
                    // 检查成就
                    this.checkAchievements(index + 1);
                    this.checkAchievements(102);
                },
                calcBulkCost(index) {
                    const building = this.buildings[index];
                    const r = new Decimal(1.148698354997035); // 价格增长系数
                    const n = N(parseInt(this.bulkAmount));
                    const a1 = building.cost;
                    if (n == 1) return a1.mul(this.goldenPeiEffects.buildingCostReduction);
                    // 使用等比数列求和公式：S = a1*(r^n - 1)/(r - 1)
                    return r.pow(n).sub(1).mul(a1).div(r.sub(1)).mul(this.goldenPeiEffects.buildingCostReduction);
                },
                canBulkBuy(index) {
                    return this.peiCount.gte(this.calcBulkCost(index));
                },
                buyUpgrade(i, b) {
                    const upgrade = this.upgrades.filter(u => u.id == i && u.buildingId == b)
                    const c = upgrade[0].cost.mul(this.goldenPeiEffects.upgradeCostReduction);
                    if (this.canBuyUpgrade(i , b)) {
                        this.peiCount = this.peiCount.sub(c);
                        this.upgrades.filter(u => u.id == i && u.buildingId == b).map(u => u.unlocked = true);
                    }
                    //检查成就
                    this.checkAchievements(102);
                },
                // 判断是否可以购买升级
                canBuyUpgrade(i , b) {
                    const upgrade = this.upgrades.filter(u => u.id == i && u.buildingId == b);
                    const c = upgrade[0].cost.mul(this.goldenPeiEffects.upgradeCostReduction);
                    return this.peiCount.gte(c) && !upgrade[0].unlocked
                },
                // 判断升级是否显示
                showUpgrade(i , b) {

                },
                checkAchievements(buildingIndex) {
                    const relatedAchievements = this.achievements.filter(
                        a => a.buildingId === buildingIndex
                    );
                    if (buildingIndex < 100) {
                        const building = this.buildings[buildingIndex-1];
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && building.quantity.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                    if (buildingIndex == 101) {
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && this.totalLifetimePei.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                    if (buildingIndex == 102) {
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && this.peiPerSecond.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                    if (buildingIndex == 103) {
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && this.totalClickPei.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                    if (buildingIndex == 104) {
                        relatedAchievements.forEach(achievement => {
                            if (!achievement.unlocked && this.totalRealityShards.gte(achievement.required)) {
                                achievement.unlocked = true;
                                this.showAchievementToast(achievement);
                            }
                        });
                    }
                },
                showAchievementToast(achievement) {
                    this.milk = N(this.unlockedAchievementsCount);
                    const toast = document.createElement('div');
                    toast.className = 'achievement-toast';
                    toast.innerHTML = `
                <span>成就 </span>
                <strong>${achievement.buildingId}-${achievement.id}</strong>
                <span> 已解锁</span>`
                    ;
                    document.body.appendChild(toast);

                    setTimeout(() => {
                        toast.remove();
                    }, 5000);
                },
                ascend() {
                    if (!this.canAscend) return;

                    // 计算获得的碎片
                    const gained = this.totalShards.sub(this.totalRealityShards).max(0);
                    this.realityShards = this.realityShards.add(gained);
                    this.totalRealityShards = this.totalShards;
                    this.ascensionCount = this.ascensionCount.add(1);
                    this.checkAchievements(104);
                    // 重置游戏状态
                    this.peiCount = N(0);
                    this.thisAscendPei = N(0);
                    this.buildings.forEach(b => {
                        b.quantity = N(0);
                        b.cost = b.baseCost;
                        b.production = b.baseProd;
                    });
                    this.upgrades.forEach(u => {
                        u.unlocked = false;
                    });
                },
                buyAscendU(index) {
                    const upgrade = this.ascendU[index];
                    if (upgrade.level.gte(upgrade.maxLevel)) return;

                    if (this.realityShards.gte(upgrade.cost)) {
                        this.realityShards = this.realityShards.sub(upgrade.cost);
                        this.ascendU[index].level = this.ascendU[index].level.add(1);
                    }
                    if (index == 1) this.ascendU[1].cost = N(3).add(this.ascendU[1].level.mul(3)).mul(N(10).pow(this.ascendU[1].level.mul(6)));
                    if (index == 2) this.ascendU[2].cost = N(5).add(this.ascendU[2].level.mul(10));
                    if (index == 3) this.ascendU[3].cost = N(7).pow(this.ascendU[3].level.add(1));
                    if (index == 4) this.ascendU[4].cost = N(50).mul(N(100).pow(this.ascendU[4].level));

                },
                format(decimal) {
                    let e = decimal.exponent.toFixed(0);
                    let m = decimal.mantissa.toFixed(3);
                    let ee = Math.floor(Math.log10(decimal.exponent)).toFixed(0);
                    let mm = (decimal.exponent / Math.pow(10, ee)).toFixed(3);
                    if(m == "10.000") m = "9.999";
                    if (mm == "10.000") mm = "9.999";
                    if (decimal.lt(10)) return decimal.toFixed(3);
                    if (decimal.lt(100)) return decimal.toFixed(2);
                    if (decimal.lt(1000)) return decimal.toFixed(1);
                    else if (decimal.lt(1e12)) return this.comma(decimal);
                    else if (decimal.lt("1e1000000000000")) return m + "e" + this.comma(e);
                    else return m + "e" + mm + "e" + ee;
                },
                formatInt(decimal) {
                    let e = decimal.exponent.toFixed(0);
                    let m = decimal.mantissa.toFixed(3);
                    let ee = Math.floor(Math.log10(decimal.exponent)).toFixed(0);
                    let mm = (decimal.exponent / Math.pow(10, ee)).toFixed(3);
                    if (m == "10.000") m = "9.999";
                    if (mm == "10.000") mm = "9.999";
                    else if (decimal.lt(1e12)) return this.comma(decimal);
                    else if (decimal.lt("1e1000000000000")) return m + "e" + this.comma(e);
                    else return m + "e" + mm + "e" + ee;
                },
                comma(num) {
                    if (num === null || num === undefined) return "NaN"
                    let init = num.toString()
                    let portions = init.split(".")
                    portions[0] = portions[0].replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1,")
                    return portions[0]
                },
                saveGame() {
                    // 1. 获取原始数据
                    const saveData = {
                        peiCount: this.peiCount,
                        thisAscendPei: this.thisAscendPei,
                        totalLifetimePei: this.totalLifetimePei,
                        totalClickPei: this.totalClickPei,
                        goldenPeiClick: this.goldenPeiClick,

                        buildings: this.buildings,
                        upgrades: this.upgrades,
                        achievements: this.achievements,

                        ascensionCount: this.ascensionCount,
                        realityShards: this.realityShards,
                        totalRealityShards: this.totalRealityShards,
                        ascendU: this.ascendU,

                        milk: this.milk,
                        sugar: this.sugar,
                        playTime: this.playTime,
                        totalPlayTime: this.totalPlayTime,
                        lastUpdateTime: Date.now(),
                        // ...其他需要保存的数据...
                    };

                    // 2. 转换为JSON字符串
                    const save= formatsave.encode(JSON.stringify(saveData))

                    // 3. 显示给用户（示例）
                    prompt("请复制存档代码", save);
                    navigator.clipboard.writeText(save);
                },
                loadGame() {
                    const save = prompt("请输入存档代码");

                        // 4. 解析JSON
                    const saveData = JSON.parse(formatsave.decode(save));

                    transformToDecimal(saveData);

                        // 5. 应用存档数据
                    this.peiCount = saveData.peiCount;
                    this.thisAscendPei = saveData.thisAscendPei;
                    this.totalLifetimePei = saveData.totalLifetimePei;
                    this.totalClickPei = saveData.totalClickPei;
                    this.goldenPeiClick = saveData.goldenPeiClick;

                    this.buildings = saveData.buildings;
                    this.upgrades = saveData.upgrades;
                    this.achievements = saveData.achievements;

                    this.ascensionCount = saveData.ascensionCount;
                    this.realityShards = saveData.realityShards;
                    this.totalRealityShards = saveData.totalRealityShards;
                    this.ascendU = saveData.ascendU;

                    this.milk = saveData.milk;
                    this.sugar = saveData.sugar;
                    this.playTime = saveData.playTime;
                    this.totalPlayTime = saveData.totalPlayTime;

                    this.handleOfflineProduction(saveData.lastUpdateTime);
                    alert("存档加载成功！");
                },
                localSave() {
                    const saveData = {
                        peiCount: this.peiCount,
                        thisAscendPei: this.thisAscendPei,
                        totalLifetimePei: this.totalLifetimePei,
                        totalClickPei: this.totalClickPei,
                        goldenPeiClick: this.goldenPeiClick,

                        buildings: this.buildings,
                        upgrades: this.upgrades,
                        achievements: this.achievements,

                        ascensionCount: this.ascensionCount,
                        realityShards: this.realityShards,
                        totalRealityShards: this.totalRealityShards,
                        ascendU: this.ascendU,

                        milk: this.milk,
                        sugar: this.sugar,
                        playTime: this.playTime,
                        totalPlayTime: this.totalPlayTime,
                        lastUpdateTime: Date.now(),
                        // ...其他需要保存的数据...
                    };

                    localStorage.pelkieClickerSave = formatsave.encode(JSON.stringify(saveData));

                },
                localLoad() {
                    if (!localStorage.pelkieClickerSave) return;

                    const saveData = JSON.parse(formatsave.decode(localStorage.pelkieClickerSave));

                    transformToDecimal(saveData);

                    // 5. 应用存档数据
                    this.peiCount = saveData.peiCount;
                    this.thisAscendPei = saveData.thisAscendPei;
                    this.totalLifetimePei = saveData.totalLifetimePei;
                    this.totalClickPei = saveData.totalClickPei;
                    this.goldenPeiClick = saveData.goldenPeiClick;

                    this.buildings = saveData.buildings;
                    this.upgrades = saveData.upgrades;
                    this.achievements = saveData.achievements;

                    this.ascensionCount = saveData.ascensionCount;
                    this.realityShards = saveData.realityShards;
                    this.totalRealityShards = saveData.totalRealityShards;
                    this.ascendU = saveData.ascendU;

                    this.milk = saveData.milk;
                    this.sugar = saveData.sugar;
                    this.playTime = saveData.playTime;
                    this.totalPlayTime = saveData.totalPlayTime;

                    this.handleOfflineProduction(saveData.lastUpdateTime);
                },
                hardReset() {
                    if (confirm("是否硬重置?这将重置你的所有进度!")) {
                        // 用户点击了确定
                        this.peiCount = N(0);
                        this.thisAscendPei = N(0);
                        this.totalLifetimePei = N(0);
                        this.totalClickPei = N(0);
                        this.goldenPeiClick = 0;

                        this.buildings= Array.from({ length: 42 }, (_, i) => ({
                            id: i,
                            quantity: N(0),
                            baseCost: N(10).pow(i * (i - 1) / 40 + i + 1),
                            cost: N(10).pow(i * (i - 1) / 40 + i + 1),
                            baseProd: N(8).pow(i - 1),
                            production: N(8).pow(i - 1),
                        })),
                        this.upgrades= UPGRADES.map(u => ({
                                ...u,
                                unlocked: false,
                            })),
                        this.achievements= ACHIEVEMENTS.map(a => ({
                                    ...a,
                                    unlocked: false,
                                })),
                        this.ascendU= ASCENDU.map(r => ({
                                ...r,
                                unlocked: false,
                                level: N(0),
                            })),

                        this.ascensionCount = N(0);
                        this.realityShards = N(0);
                        this.totalRealityShards = N(0);
                        this.milk = N(0);
                        this.sugar = N(0);
                        this.playTime = N(0);
                        this.totalPlayTime = N(0);
                    }
                    else return;
                },
                handleOfflineProduction(savedTime) {
                    if (!savedTime) return;

                    const currentTime = Date.now();
                    const offlineTime = Math.min(currentTime - savedTime, this.ascendU[3].level.toNumber() * 21600000 + 21600000);
                    const offlineSeconds = offlineTime / 1000;

                    if (offlineSeconds > 1) {
                        // 计算离线收益
                        const production = this.totalProduction.mul(offlineSeconds);
                        this.peiCount = this.peiCount.add(production);
                        this.thisAscendPei = this.thisAscendPei.add(production);
                        this.totalLifetimePei = this.totalLifetimePei.add(production);
                        this.sugar = this.sugar.add(Math.floor(offlineSeconds / 3600));
                        this.playTime = this.playTime + (offlineSeconds % 3600);
                        this.totalPlayTime = this.totalPlayTime + offlineSeconds;
                        // 显示离线通知
                        this.showOfflineNotification(offlineSeconds, production);
                    }
                },
                showOfflineNotification(seconds, amount) {
                    const hours = Math.floor(seconds / 3600);
                    const mins = Math.floor((seconds % 3600) / 60);
                    const secs = Math.floor(seconds % 60);
                    const toast = document.createElement('div');
                    toast.className = 'offline-toast';
                    toast.innerHTML = `
                <p>你离线了 ${hours}h${mins}m${secs}s</p>
                <p>离线产量: ${this.format(amount.div(seconds).mul(0.8))}</p>
                <p>效率: 80%, 时长上限: ${this.ascendU[3].level.toNumber()*6+6}h</p>
                <p>获得 ${this.format(amount)} 佩干</p>
                <p>获得 ${this.formatInt(N(seconds / 3600))} 糖块</p>
            `;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 5000);
                },
                // 其他方法...
            },
            computed: {
                // 带升级加成的总生产量
                totalClick() {
                    let base = N(this.goldenPeiEffects.clickMultiplier);
                    let mult = this.upgrades.filter(u => u.buildingId == 1 && u.id < 4).reduce((prod, upgrade) => {
                        return upgrade.unlocked ? prod.mul(2) : prod;
                    }, N(1));
                    if (this.upgrades.filter(u => u.buildingId == 1 && u.id == 4)[0].unlocked) {
                        mult = mult.add(this.upgrades.filter(u => u.buildingId == 1 && u.id > 4).reduce((prod, upgrade) => {
                            return upgrade.unlocked ? prod.mul(20) : prod;
                        }, N(1)).mul(this.nonB1Count));
                    }
                    mult = mult.mul(this.upgrades.filter(u => u.buildingId == 101).reduce((prod, upgrade) => {
                        return upgrade.unlocked ? prod.mul(1.01) : prod;
                    }, N(1)));
                    
                    return base.mul(mult).mul(this.sugarBonus).mul(this.milkBonus).mul(this.ascendBonus);
                },
                totalProduction() {
                    let base = this.buildings.reduce((sum, building, index) => {
                        let buildingMult = N(1);
                        if (index == 0) {
                            buildingMult = this.upgrades.filter(u => u.buildingId == 1 && u.id < 4).reduce((prod, upgrade) => {
                                return upgrade.unlocked ? prod.mul(2) : prod;
                            }, N(1))
                            .mul(this.goldenPeiEffects.randomBuildingBoost == index ? 1.1 : 1);    ;
                            if (this.upgrades.filter(u => u.buildingId == 1 && u.id == 4)[0].unlocked) {
                                buildingMult = buildingMult.add(this.upgrades.filter(u => u.buildingId == 1 && u.id > 4).reduce((prod, upgrade) => {
                                    return upgrade.unlocked ? prod.mul(20) : prod;
                                }, N(1)).mul(this.nonB1Count));
                            }
                        }
                        if (index == 1) {
                            buildingMult = this.upgrades.filter(u => u.buildingId == 2).reduce((prod, upgrade) => {
                                return upgrade.unlocked ? prod.mul(2) : prod;
                            }, N(1))
                            .mul(this.upgrades.filter(u => u.buildingId == 103).reduce((prod, upgrade) => {
                                return upgrade.unlocked ? prod.mul(2) : prod;
                            }, N(1)))
                            .mul(this.goldenPeiEffects.randomBuildingBoost == index? 1.1:1);
                        }
                        if (index >= 2) {
                            buildingMult = this.upgrades.filter(u => u.buildingId == (index + 1)).reduce((prod, upgrade) => {
                                return upgrade.unlocked ? prod.mul(2) : prod;
                            }, N(1))
                                .mul(this.upgrades.filter(u => u.buildingId == 103 && u.id == index - 1)[0].unlocked ? N(1).add(this.buildings[1].quantity.div(index - 1).div(100)) : N(1))
                                .mul(this.goldenPeiEffects.randomBuildingBoost == index ? 1.1 : 1);
                        }
                        building.production = building.quantity.mul(building.baseProd).mul(buildingMult)
                        return sum.add(building.production);
                    }, N(0));
                    let milkMult = this.upgrades.filter(u => u.buildingId == 102).reduce((prod, upgrade, i) => {
                        let factor = i < 8 ? i < 4 ? N(0.004).add(0.001 * i) : N(0.008) : i < 12 ? N(0.016).sub(0.001 * i) : N(0.004);
                        return upgrade.unlocked ? prod.mul(factor.mul(this.unlockedAchievementsCount).add(1)) : prod;
                    }, N(1));
                    this.milkBonus = milkMult;
                    let sugarMult = this.sugar.mul(0.001).add(1);
                    this.sugarBonus = sugarMult;
                    let ascendMult = this.upgrades.filter(u => u.buildingId == 104).reduce((sum, upgrade, i) => {
                        let factor=[0.05,0.2,0.25,0.25,0.25,]
                        if (i < 5) return upgrade.unlocked ? sum.add(this.totalRealityShards.mul(factor[i])) : sum;
                        if (i == 5) return upgrade.unlocked ? sum.mul(1.01) : sum;
                        if (i == 6) return upgrade.unlocked ? sum.mul(1.1) : sum;
                    }, N(1));
                    this.ascendBonus = ascendMult;
                    let pelkieMult = this.upgrades.filter(u => u.buildingId == 105).reduce((sum, upgrade) => {
                        return upgrade.unlocked ? sum.mul(N(1).add(N(upgrade.id-1).add(10).div(10).floor().div(100))) : sum;
                    }, N(1));

                    if (this.ascendU[1].level.gte(1)) base = base.mul(1.1);
                    return base.mul(milkMult).mul(sugarMult).mul(ascendMult).mul(pelkieMult).mul(this.goldenPeiEffects.buildingMultiplier);
                },
                nonB1Count() {
                    let sum = N(0);
                    for (i = 1; i < (this.buildings.length - 1); i++) sum = sum.add(this.buildings[i].quantity);
                    return sum;
                },
                unlockedUpgradesCount() {
                    return this.upgrades.filter(u => u.unlocked).length;
                },
                unlockedAchievementsCount() {
                    return this.achievements.filter(a => a.unlocked).length;
                },
                canAscend() {
                    return this.totalLifetimePei.gte(1e12);
                },
                totalShards() {
                    return this.totalLifetimePei.gte(1e48) ? this.totalLifetimePei.pow(1 / 4).floor() : this.totalLifetimePei.div(1e12).pow(1 / 3).floor();
                },
                nextShards() {
                    return this.totalLifetimePei.gte(1e48) ? this.totalShards.add(1).pow(4) : this.totalShards.add(1).pow(3).mul(1e12);
                },
            },
            mounted() {
                this.localLoad();
                // 游戏循环
                setInterval(() => {
                    // 使用computed属性计算生产量
                    this.peiPerClick = this.totalClick;
                    this.peiPerSecond = this.totalProduction;
                    this.peiCount = this.peiCount.add(this.totalProduction.div(50));
                    this.thisAscendPei = this.thisAscendPei.add(this.totalProduction.div(50));
                    this.totalLifetimePei = this.totalLifetimePei.add(this.totalProduction.div(50));
                }, 20);
                setInterval(() => {
                    this.goldenPeiTimer++
                    this.playTime++;
                    this.totalPlayTime++;
                    if (this.playTime >= 3600) {
                        this.sugar = this.sugar.add(1);
                        this.playTime = 0;
                    }
                    let t = this.upgrades.filter(u => u.buildingId == 105 && u.id == 1).unlocked ? 150 : 300;
                    let l = this.upgrades.filter(u => u.buildingId == 105 && u.id == 1).unlocked ? 30 : 15;
                    if (this.goldenPeiTimer >= t) {
                        this.goldenPeiVisible = true;
                        setTimeout(() => {
                            this.goldenPeiVisible = false;
                        }, 1000*l);
                        this.goldenPeiTimer = 0;
                    }
                    this.checkAchievements(101);
                }, 1000);
                setInterval(() => {
                    this.localSave();
                },10000)
            }
        });
    </script>
</body>
</html>